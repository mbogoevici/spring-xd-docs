=== Introduction
In this section we will show some variations on output sinks.  As a prerequisite start the XD Container
as instructed in the link:Getting-Started#getting-started[Getting Started] page.

The Sinks covered are

* <<log_sinks, Log>>

* <<file_sinks, File>>

* <<hdfs, HDFS>>

* <<jdbc_sink, JDBC>>

* <<tcp_sinks, TCP>>

* <<gemfire,GemFire Server>>

* <<splunk,Splunk Server>>

* <<mqtt_sink, MQTT>>

See the section link:Creating-a-Sink-Module#creating-a-sink-module[Creating a Sink Module] for information on how to create sink modules using other Spring Integration Adapters.

[[log_sinks]]
=== Log

Probably the simplest option for a sink is just to log the data. The `log` sink uses the application logger to output the data for inspection. The log level is set to `WARN` and the logger name is created from the stream name. To create a stream using a `log` sink you would use a command like

  http://localhost:8080:> stream create --name mylogstream --definition "http --port=8000 | log"

You can then try adding some data. We've used the `http` source on port 8000 here, so run the following command to send a message

  $ curl -d "hello" http://localhost:8000

and you should see the following output in the XD container console.

  13/06/07 16:12:18 WARN logger.mylogstream: hello

The logger name is the sink name prefixed with the string "logger.". The sink name is the same as the stream name by default, but you can set it by passing the `--name` parameter 

  http://localhost:8080:> stream create --name myotherlogstream --definition "http --port=8000 | log --name=mylogger"

[[file_sinks]]
=== File Sink

Another simple option is to stream data to a file on the host OS. This can be done using the `file` sink module to create a link:Streams#streams[stream].

  http://localhost:8080:> stream create --name myfilestream --definition "http --port=8000 | file"

We've used the `http` source again, so run the following command to send a message

  $ curl -d "hello" http://localhost:8000

The `file` sink uses the stream name as the default name for the file it creates, and places the file in the `/tmp/xd/output/` directory.

  $ less /tmp/xd/output/myfilestream
  hello

You can cutomize the behavior and specify the `name` and `dir` properties of the output file. For example

  http://localhost:8080:> stream create --name otherfilestream --definition "http --port=8000 | file --name=myfile --dir=/some/custom/directory"

[[hdfs]]
=== Hadoop (HDFS)


First install and start Hadoop as described in our link:Hadoop-Installation#hadoop-installation[separate guide]. It's assumed HDFS is running on port 9000 (the default).

You should then be able to use the `hdfs` sink when creating a link:Streams#streams[stream]

  http://localhost:8080:> stream create --name myhdfsstream --definition "http --port=8000 | hdfs --rollover=10"

Note that we've set the `rollover` parameter to a small value for this exercise. This is just to avoid buffering, so that we can actually see the data has made it into HDFS.

As in the above examples, we've used the `http` source on port 8000, so we can post some data again using

  $ curl -d "hello" http://localhost:8000

Repeat the command a few times.

If you list the hadoop filesystem contents using `hadoop fs -ls /`, you should see that an `xd` directory has appeared in the root with a sub-directory named after our stream

  $ hadoop dfs -ls /xd
  Found 1 items
  drwxr-xr-x   - luke supergroup          0 2013-05-28 14:53 /xd/myhdfsstream

And there will be one or more log files in there depending how many times you ran the command to post the data

  $ hadoop dfs -ls /xd/myhdfsstream
  Found 1 items
  -rw-r--r--   3 luke supergroup          0 2013-05-28 14:53 /xd/myhdfsstream/myhdfsstream-0.log

You can examine the file contents using `hadoop fs -cat`

  $ hadoop dfs -cat /xd/myhdfsstream/myhdfsstream-0.log
  hello
  hello

==== HDFS with Options

The HDFS Sink has the following options:

newline:: whether to append a newline to the message payload *(default: `true`)*
directory:: where to output the files in the Hadoop FileSystem *(default: `/xd/<streamname>`)*
filename:: the base filename to use for the created files (a counter will be appended before the file extension). *(default: `<streamname>`)*
suffix:: the file extension to use *(default: `log`)*
rollover:: when to roll files over, expressed in bytes *(default: `1000000`, roughly 1MB)*

[[jdbc_sink]]
=== JDBC

The JDBC sink can be used to insert message payload data into a relational database table. By default it inserts the entire payload into an in-memory HSQLDB database table named after the stream name. To alter this behavior you should modify the 'config/jdbc.properties' file with the connection parameters you want to use. There is also a 'config/init_db.sql' file that contains the SQL statements used to initialize the database table. You can modify this file if you'd like to create the table when the sink starts or change the 'initializeDatabase' property to 'false' if the table already exists.

The payload data will be inserted as is if the columns to be used is specified as 'payload'. This is the default behavior. If you specify any other column names the payload data will be assumed to be a JSON document that will be converted to a hash map. This hash map will be used to populate the data values for the SQL insert statement. There will be one insert statement executed for each message.

To create a stream using a `jdbc` sink relying on all defaults you would use a command like

  http://localhost:8080:> stream create --name myjdbc --definition "time | jdbc"

This will insert the time messages into a 'payload' column in a table named 'myjdbc'. Since the default is using an in-memory HSQLDB database we can't connect to this database instance from an external tool. In order to do that we need to alter the connection properties. We can either modify the 'config/jdbc.properties' file or provide the 'url' property when we create the stream. Here is an example of the latter:

  http://localhost:8080:> stream create --name mydata --definition "time | jdbc --url='jdbc:hsqldb:file:/tmp/xd/test'"
 
We let the stream run for a little while and then destroy it so we can look at the data stored in the database.

  http://localhost:8080:> stream destroy --name mydata

You can use the above database URL from your favorite SQL tool or we can use the HSQL provided SQL Tool to run a quick query from the command line:
 
  $ java -cp $XD_HOME/lib/hsqldb-1.8.0.10.jar org.hsqldb.util.SqlTool --inlineRc url=jdbc:hsqldb:file:/tmp/xd/test,user=sa,password= --sql "select payload from mydata;"

This should result in something similar to the following output:

  2013-07-29 12:05:48
  2013-07-29 12:05:49
  2013-07-29 12:05:50
  2013-07-29 12:05:51
  2013-07-29 12:05:52
  2013-07-29 12:05:53
  2013-07-29 12:05:54
  2013-07-29 12:05:55
  2013-07-29 12:05:56
  2013-07-29 12:05:57

  Fetched 10 rows.

==== JDBC with Options

The JDBC Sink has the following options:

configProperties:: base name of properties file containing configuration options for the sink. This file should contain the usual JDBC properties - driverClass, url, username, password *(default: `jdbc`)*
initializeDatabase:: whether to initialize the database using theinitializer script (the default propertry file jdbc.properties has this set to true) *(default: `false`)*
initializerScript:: the file name for the script containing SQL statements used to initialize the database when the sink starts (will search config directory for this file) *(default: `init_db.sql`)*
tablename:: the name of the table to insert payload data into *(default: `<streamname>`)*
columns:: comma separated list of column names to include in the insert statement. Use 'payload' to include the entire message payload into a payload column. *(default: `payload`)*

[[tcp_sinks]]
=== TCP

The TCP Sink provides for outbound messaging over TCP.

The following examples use `netcat` (linux) to receive the data; the equivalent on Mac OSX is `nc`.

First, start a netcat to receive the data, and background it

     $ netcat -l 1234 &

Now, configure a stream

     http://localhost:8080:> stream create --name tcptest --definition "time --interval=3 | tcp"

This sends the time, every 3 seconds to the default tcp Sink, which connects to port `1234` on `localhost`.

----
$ Thu May 30 10:28:21 EDT 2013
Thu May 30 10:28:24 EDT 2013
Thu May 30 10:28:27 EDT 2013
Thu May 30 10:28:30 EDT 2013
Thu May 30 10:28:33 EDT 2013
----

TCP is a streaming protocol and some mechanism is needed to frame messages on the wire. A number of encoders are available, the default being 'CRLF'.

Destroy the stream; netcat will terminate when the TCP Sink disconnects.

    http://localhost:8080> stream destroy --name tcptest

==== TCP with Options

The TCP Sink has the following options

host:: the host (or IP Address) to connect to *(default: `localhost`)*
port:: the port on the `host` *(default `1234`)*
reverse-lookup:: perform a reverse DNS lookup on IP Addresses *(default: `false`)*
nio:: whether or not to use NIO *(default: `false`)*
encoder:: how to encode the stream  - see below *(default: `CRLF`)*
close:: whether to close the socket after each message *(default: `false`)*
charset:: the charset used when converting text from `String` to bytes *(default: `UTF-8`)*

Retry Options

retry-max-attempts:: the maximum number of attempts to send the data *(default: `5` - original request and 4 retries)*
retry-initial-interval:: the time (ms) to wait for the first retry *(default: `2000`)*
retry-multiplier:: the multiplier for exponential back off of retries *(default: `2`)*

With the default retry configuration, the attempts will be made after 0, 2, 4, 8, and 16 seconds.

==== Available Encoders

.Text Data

CRLF (default):: text terminated by carriage return (0x0d) followed by line feed (0x0a)
LF:: text terminated by line feed (0x0a)
NULL:: text terminated by a null byte (0x00)
STXETX:: text preceded by an STX (0x02) and terminated by an ETX (0x03)

.Text and Binary Data

RAW:: no structure - the client indicates a complete message by closing the socket
L1:: data preceded by a one byte (unsigned) length field (supports up to 255 bytes)
L2:: data preceded by a two byte (unsigned) length field (up to 2^16^-1 bytes)
L4:: data preceded by a four byte (signed) length field (up to 2^31^-1 bytes)


==== An Additional Example

Start netcat in the background and redirect the output to a file `foo`

     $ netcat -l 1235 > foo &

Create the stream, using the `L4` encoder

     http://localhost:8080:> stream create --name tcptest --definition "time --interval=3 | tcp --encoder=L4 --port=1235"

Destroy the stream

     http://localhost:8080> stream destroy --name tcptest

Check the output

----
$ hexdump -C foo
00000000  00 00 00 1c 54 68 75 20  4d 61 79 20 33 30 20 31  |....Thu May 30 1|
00000010  30 3a 34 37 3a 30 33 20  45 44 54 20 32 30 31 33  |0:47:03 EDT 2013|
00000020  00 00 00 1c 54 68 75 20  4d 61 79 20 33 30 20 31  |....Thu May 30 1|
00000030  30 3a 34 37 3a 30 36 20  45 44 54 20 32 30 31 33  |0:47:06 EDT 2013|
00000040  00 00 00 1c 54 68 75 20  4d 61 79 20 33 30 20 31  |....Thu May 30 1|
00000050  30 3a 34 37 3a 30 39 20  45 44 54 20 32 30 31 33  |0:47:09 EDT 2013|
----

Note the 4 byte length field preceding the data generated by the `L4` encoder.

[[gemfire]]
=== GemFire Server

Currently XD supports GemFire's client-server topology. A sink that writes data to a GemFire cache requires a cache server to be running in a separate process and its host and port must be known (NOTE: GemFire locators are not supported yet).  The XD distribution includes a GemFire server executable suitable for development and test purposes. It is made available under GemFire's development license and is limited to 3 nodes. Modules that write to GemFire create a client cache and client region. No data is cached on the client.

==== Launching the XD GemFire Server


A GemFire Server is included in the Spring XD distribution. To start the server. Go to the XD install directory:

   $cd gemfire/bin
   $./gemfire-server cqdemo.xml

The command line argument is the location of a Spring file with a configured cache server. A sample cache configuration is provided https://github.com/SpringSource/spring-xd/blob/master/spring-xd-gemfire-server/config/cq-demo.xml[cq-demo.xml]. This starts a server on port 40404 and creates a region named _Stocks_. A Logging cache listener is configured for the region to log region events. 

==== Gemfire sinks

There are 2 implementation of the gemfire sink: _gemfire-server_ and _gemfire-json-server_. They are identical except the latter converts JSON string payloads to a JSON document format  proprietary to GemFire and provides JSON field access and query capabilities. If you are not using JSON, the gemfire-server module will write the payload using java serialization to the configured region. Either of these modules accepts the following attributes:

regionName:: the name of the GemFire region. This must be the name of a region configured for the cache server. This module creates the corresponding client region. *(default: `<streamname>`)*
keyExpression:: A SpEL expression which is evaluated to create a cache key. Typically, the key value is derived from the payload. *(default: `<streamname>`, which will overwrite the same entry for every message received on the stream)*
gemfireHost:: The host name or IP address of the cache server *(default: `localhost`)*
gemfirePort:: The TCP port number of the cache server *(default: `40404`)*

==== Example
Suppose we have a JSON document containing a stock price:

      {"symbol":"VMW", "price":73} 

We want this to be cached using the stock symbol as the key. The stream definition is:

     http | gemfire-json-server --regionName=Stocks --keyExpression=payload.getField('symbol')

The keyExpression is a SpEL expression that depends on the payload type. In this case, _com.gemstone.org.json.JSONObject. JSONObject_ which  provides the _getField_ method. To run this example:

    http://localhost:8080:> stream create --name stocks --definition "http --port=9090 | gemfire-json-server --regionName=Stocks --keyExpression=payload.getField('symbol')"
    $ curl -d "{\"symbol\":\"VMW\", \"price\":73}" http://localhost:9090

This will write an entry to the GemFire _Stocks_ region with the key _VMW_. You should see a message on STDOUT for the process running the GemFire server like:

    INFO [LoggingCacheListener] - updated entry VMW

[[splunk]]
=== Splunk Server
A Splunk sink that writes data to a TCP Data Input type for Splunk. 

==== Splunk sinks
The Splunk sink converts an object payload to a string using the object’s toString method and then converts this to a SplunkEvent that is sent via TCP to Splunk.  The module accepts the following attributes:

host::
The host name or IP address of the Splunk server *(default: `localhost`)
port::
The TCP port number of the Splunk Server *(default: `8089`)*
username::
The login name that has rights to send data to the tcp-port *(default: `admin`)*
password::
The password associated with the username *(default: `password`)*
owner::
The owner of the tcp-port *(default: `admin1`)*
tcp-port::
The TCP port number to where XD will send the data *(default: `9500`)*

==== Setup Splunk for TCP Input
. From the Manager page select `Data inputs` link
. Click the `Add Data` Button
. Click the `TCP` link
. Click the 'New' Button
. `TCP Port` enter the port you want Splunk to monitor
. `Set Source Type` select `manual`
. `Source Type` enter `tcp-raw`

==== Example
An example stream would be to take data from a twitter search and push it through to a splunk instance.

    http://localhost:8080:> stream create --name springone2gx --definition "twittersearch --consumerKey= --consumerSecret= --query='#LOTR' | splunk"

[[mqtt_sink]]
=== MQTT
The mqtt sink connects to an mqtt server and publishes telemetry messages.

==== Options

The folllowing options are configured in mqtt.properties in XD_HOME/config

    mqtt.url=tcp://localhost:1883
    mqtt.default.client.id=xd.mqtt.client.id
    mqtt.username=guest
    mqtt.password=guest
    mqtt.default.topic=xd.mqtt.test

The defaults are set up to connect to the RabbitMQ MQTT adapter on localhost.

Note that the client id must be no more than 19 characters; this is because `.snk` is added and the id must be no more than 23 characters.

clientId:: Identifies the client - overrides the default above.
topic:: The topic to which the sink will publish - overrides the default above.
qos:: The Quality of Service (default: 1)
retained:: Whether the retained flag is set (default: false)

