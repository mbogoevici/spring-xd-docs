[[creating-a-processor-module]]
ifndef::env-github[]
== Creating a Processor Module
endif::[]

=== Introduction

As outlined in the link:Modules#modules[modules] document, Spring XD currently supports four types of modules: source, sink, and processor for stream processing and job for batch processing.  This document walks through implementing a custom processor module.

One or more processors can be included in a link:Streams#streams[stream] definition to modify the data as it passes between the initial source and the destination sink. The link:Architecture#architecture[architecture] section covers the basics of stream processing.  Processor modules provided out of the box are covered in the link:Processors#processors[processors] section.

Here we'll look at how to create and deploy a custom processor module to transform the input from a `twittersearch` source. The steps are essentially the same, regardless of the source. Rather than using built-in functionality, we'll write a custom processor implementation class and wire it up using Spring Integration.

=== Write the Transformer Code

The tweet messages from `twittersearch` contain quite a lot of data (id, author, time, hash tags, and so on). The transformer we'll write extracts the text of each tweet and outputs this as a string. The output messages from the `twittersearch` source are also strings, rendering the tweet data as JSON. We first load this into a map using Jackson library code, then extract the "text" field from the map.

[source,java]
----

package my.custom.transformer;

import java.io.IOException;
import java.util.Map;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;
import org.springframework.integration.transformer.MessageTransformationException;

public class TweetTransformer {
  private ObjectMapper mapper = new ObjectMapper();

  public String transform(String payload) {
    try {
      Map<String, Object> tweet = mapper.readValue(payload, new TypeReference<Map<String, Object>>() {});
      return tweet.get("text").toString();
    } catch (IOException e) {
      throw new MessageTransformationException("Unable to transform tweet: " + e.getMessage(), e);
    }
  }
}

----

=== Create the module Application Context File

Create the following file as _tweettransformer.xml_:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<beans:beans xmlns="http://www.springframework.org/schema/integration"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:beans="http://www.springframework.org/schema/beans"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/integration
    http://www.springframework.org/schema/integration/spring-integration.xsd">
  <channel id="input"/>

  <transformer input-channel="input" output-channel="output">
    <beans:bean class="custom.TweetTransformer" />
  </transformer>

  <channel id="output"/>
</beans:beans>
----

Alternately, you can create the application context using an @Configuration class. In the example below, we've combined the configuration and the transformer into a single Java file for simplicity. Note that TweetTransformer now includes Spring Integration annotations: 

[source, java]
----
package my.custom.transformer;

import java.io.IOException;
import java.util.Map;

import my.custom.transformer.TweetTransformer;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.type.TypeReference;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.annotation.MessageEndpoint;
import org.springframework.integration.annotation.Transformer;
import org.springframework.integration.channel.DirectChannel;
import org.springframework.integration.config.EnableIntegration;
import org.springframework.integration.transformer.MessageTransformationException;
import org.springframework.messaging.MessageChannel;

@Configuration
@EnableIntegration
public class ModuleConfiguration {
  @Autowired
  TweetTransformer transformer;

  @Bean
  public MessageChannel input() {
    return new DirectChannel();
  }

  @Bean
  MessageChannel output() {
    return new DirectChannel();
  }
}

@MessageEndpoint
class TweetTransformer {
  private ObjectMapper mapper = new ObjectMapper();

  @Transformer(inputChannel = "input", outputChannel = "output")
  public String transform(String payload) {
    try {
      Map<String, Object> tweet = mapper.readValue(payload, new TypeReference<Map<String, Object>>() {
      });
      return tweet.get("text").toString();
    }
    catch (IOException e) {
      throw new MessageTransformationException("Unable to transform tweet: " + e.getMessage(), e);
    }
  }
}

----

=== Registering the Module


To register the module, create a simple jar file including the configuration and custom code and copy it to the `${xd.home}/modules/processors` directory. 

The jar must contain a top level _config_ directory. If using XML configuration, _tweettransformer.xml_ should go in _config_.  If using annotated configuration, create _/config/tweettransformer.properties_  to declare the base packages to scan:

----
base_packages = my.custom.transformer
----

[NOTE]
====
The installed jar should be renamed to _tweettransformer.jar_ (or whatever you would like to name the module), embedded versions will be interpreted as part of the module name.
====

[NOTE] 
====
A simple jar file works in this case because the module requires no additional library dependencies since the Spring XD class path already includes Jackson and Spring Integration. See link:Modules#module-packaging[Module Packaging] for more details. 
====

=== Test the custom module

Start the Spring XD runtime and try creating a stream to test your processor:

  xd:> stream create --name javatweets --definition "twittersearch --query=java --consumerKey=<your_key> --consumerSecret=<your_secret> | tweettransformer | file" --deploy

If you haven't already used `twittersearch`, read the link:Sources#sources[sources] section for more details. This command should stream tweets to the file `/tmp/xd/output/javatweets` but, unlike the normal `twittersearch` output, you should just see the plain tweet text there, rather than the full JSON data.

