=== Introduction

XD allows you to declaratively configure type conversion within processing streams using _inputType_ and _outputType_ parameters on module definitions. Note that general type conversion may be accomplished easily within a transformer or a custom module. Currently, XD natively supports the following type conversions commonly used in streams: 

* *JSON* to/from *POJO* 
* *JSON* to/from https://github.com/spring-projects/spring-xd/blob/master/spring-xd-tuple/src/main/java/org/springframework/xd/tuple/Tuple.java[org.springframework.xd.tuple.Tuple]
* *Object* to/from *byte[]* : Either the raw bytes serialized for remote transport, bytes emitted by a module, or converted to bytes using Java serialization(requires the object to be Serializable)
* *String* to/from *byte[]*
* *Object* to *plain text* (invokes the object's _toString()_ method)

Where _JSON_ represents JSON content. Currently, Objects may be unmarshalled from a JSON byte array or String. Converting to JSON produces a String. Registration of custom type converters is covered link:Extending-XD#Providing-a-New-Type-Converter[in this section].

[[MimeTypes]]
=== MIME media types
_inputType_ and _outputType_ values are parsed as media types, e.g., _application/json_ or _text/plain;charset=UTF-8_. Media types are especially useful for indicating how to convert to String or byte[] content. XD also uses standard media type format to represent Java types, using the general type _application/x-java-object_ with a _type_ parameter. For example, _application/x-java-object;type=java.util.Map_ or _application/x-java-object;type=com.bar.Foo_ . For convenience, you can specify the class name by itself and XD will map it to the corresponding media type. In addition, XD provides a namespace for internal types, notably, _application/x-xd-tuple_ to specify a Tuple. 

[[mimetype-examples]]
==== Stream Definition examples

           twittersearch --query='#springone2gx' --outputType=application/json |  file

The _twittersearch_ module produces https://github.com/spring-projects/spring-social-twitter/blob/master/spring-social-twitter/src/main/java/org/springframework/social/twitter/api/Tweet.java[Tweet] objects. Producing a domain object is useful in many cases, however writing a Tweet directly to a file would produce something like:

org.springframework.social.twitter.api.Tweet@6e878e7c

Arguably, this output is not as useful as the JSON representation. Setting the outputType to application/json causes XD to convert the default type to a JSON string before piping it to the next module. This is almost equivalent to:

           twittersearch --query='#springone2gx' | file --inputType=application/json

There are some technical differences: In the first case, the transformation is done before the object is marshalled (serialized) for remote transport. In the second case, the transformation follows unmarshalling. Perhaps a more significant difference is that a tap created on the file sink would consume JSON in the first case, and Tweets in the second. 


           twittersearch --query='#springone2gx' --outputType=application/json |  transform --inputType=application/x-xd-tuple ...

The above example illustrates a combination of outputType and inputType conversion. the Tweet is converted to a JSON string which is then converted to a Tuple. XD does not know how to convert an arbitrary type to a Tuple, but it can write an object to JSON and read JSON into a Tuple, so we have effectively performed an Object to Tuple conversion.  In many cases, combining conversion this way is not necessary, and care must be taken since XD does not validate that such combinations are possible.

The following serializes a java.io.Serializable object to a file.  Presumably the _foo_ module outputs a Serializable type. If not, this will result in an exception. If remote transport is configured, the output of _foo_ will be marshalled using XD's internal serialization mechanism. The object will be reconstituted in the _file_ module's local JVM and then converted to a byte array using Java serialization.

         foo  | --inputType=application/x-java-serialized-object file


[[mediatypes-javatypes]]
=== Media types and Java types

Internally, XD implements type conversion using Spring Integration's http://docs.spring.io/spring-integration/docs/latest-ga/reference/htmlsingle/#channel-configuration[datatype channels]. The data type channel converts payloads to the configured datatype using Spring's http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/MessageConverter.html[MessageConverter]. 

NOTE: The use of _MessageCoverter_ for data type channels was introduced in Spring Integration 4 to pass the Message to the converter method to allow it to access the Message's _content-type_ header. This provides greater flexibility. For example, it is now possible to support multiple strategies for converting a String or byte array to a POJO, depending on the content-type header.

When XD processes a module with a declared type conversion, it modifies the module's input and/or output channel definition to set the required Java type and registers MessageConverters associated with the target media type and Java type to the channel. The type conversions XD provides out of the box are summarized in the following table:

|===
|Source Payload |Target Payload |content-type header | outputType/inputType | Comments

|POJO
|JSON String
|ignored
|application/json
|

|Tuple
|JSON String
|ignored
|application/json
|JSON is tailored for Tuple

|POJO
|String (toString())
|ignored
|text/plain, java.lang.String
|

|POJO
|byte[] (java.io serialized)
|ignored
|application/x-java-serialized-object
|

|JSON byte[] or String
|POJO
|application/json (or none)
|application/x-java-object
|

|byte[] or String
|Serializable
|application/x-java-serialized-object
|application/x-java-object
|

|JSON byte[] or String
|Tuple
|application/json (or none)
|application/x-xd-tuple
|

|byte[]
|String
|any
|text/plain, java.lang.String
|will apply any Charset specified in the content-type header

|String
|byte[]
|any
|application/octet-stream
|will apply any Charset specified in the content-type header

|===

[[Caveats]]
==== Caveats
Note that that inputType and outputType parameters only apply to payloads that require type conversion. For example, if a module produces an XML string and outputType=application/json, the payload will not be converted from XML to JSON. This is because the payload at the module's output channel is already a String so no conversion will be applied at runtime.
