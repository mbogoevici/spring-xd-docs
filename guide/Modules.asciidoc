[[modules]]
ifndef::env-github[]
== Modules
endif::[]

=== Introduction

Spring XD supports data ingestion by allowing users to define link:Streams#streams[streams]. Streams are composed of _modules_ which encapsulate a unit of work into a reusable component. A job in Spring XD must also be implemented as a module.

Modules are categorized by `type`, typically representing the role or function of the module. Current Spring XD module types include `source`, `sink`, `processor`, and `job`. The type determines how the modules may be composed in a stream, or used to deploy a batch job. More precisely:

* A source polls an external resource, or is triggered by an event and only provides output. The first module in a stream must be a source. 
* A processor performs some type of task, using a message as input and produces a new message, so it requires both input and output. 

* A sink consumes input messages and outputs data to an external resource to terminate the stream. 

* A job module implements a Spring Batch job enabled for Spring XD.

Spring XD ships with a number of pre-built modules useful for assembling streams to perform common stream processing tasks using files, HDFS, Spark, Kafka, http, twitter, syslog, GemFire, and more. Users can easily assemble these modules into streams to build complex big data applications declaratively, without having to write Java code or know the underlying Spring products on which Spring XD is built.

However, if you are interested in extending Spring XD with your own modules, some knowledge of Spring, Spring Integration or Spring Batch is essential. The remainder of this document assumes the reader has some familiarity with these topics.

=== Creating a Module
This section provides details on how to implement and register custom modules. For a quick start, dive into the examples of creating link:Creating-a-Source-Module#creating-a-source-module[source], link:Creating-a-Processor-Module#creating-a-processor-module[processor], link:Creating-a-Sink-Module#creating-a-sink-module[sink], and link:Creating-a-Job-Module#creating-a-job-module[job] modules.

A https://github.com/SpringSource/spring-xd/blob/master/spring-xd-module/src/main/java/org/springframework/xd/module/ModuleDefinition.java[ModuleDefinition] requires the following attributes to uniquely define the module:

* name - the name of the component, normally a single word representing the purpose of the module. Examples are _file_, _http_, _syslog_.
* type - the module type, current Spring XD module types include _source_, _sink_, _processor_, and _job_

==== Modules and Spring
At the core, a module is any component that may be used to create a Spring application context. In this respect, the concept may be extended for purposes other than stream processing. The module types mentioned above (source, processor, sink, and job) are specific to Spring XD but other module types are envisioned.

Each module intance is configured using property placeholders which are bound to the module's options defined via link:ModuleOptionsMetadata[Module Options Metadata]. Options may be required or optional, where optional properties provide a default value.  Module Options Metadata may be provided within the module's properties file or in a Java class provided by the module or one of its dependencies. In addition to binding module options to properties in the module's application context, options may also be used to activate Spring environment profiles.

For example, here is part of the Spring configuration for the _twittersearch_ source that runs a query against Twitter:

[source,xml]
----
<beans>

  <bean class="org.springframework.integration.x.twitter.TwitterSearchChannelAdapter">
    <constructor-arg ref="twitterTemplate"/>
    <property name="readTimeout" value="${readTimeout}"/>
    <property name="connectTimeout" value="${connectTimeout}"/>
    <property name="autoStartup" value="false"/>
    <property name="outputChannel" ref="output"/>
    <property name="query" value="${query}" />
    <property name="language" value="${language}" />
    <property name="geocode" value="${geocode}" />
    <property name="resultType" value="${resultType}"/>
    <property name="includeEntities" value="${includeEntities}"/>
  </bean>

  <bean id="twitterTemplate" class="org.springframework.social.twitter.api.impl.TwitterTemplate">
    <constructor-arg value="${consumerKey}"/>
    <constructor-arg value="${consumerSecret}"/>
  </bean>

  <int:channel id="output"/>

</beans>
----

Note the Spring properties such as _query_, _language_, _consumerKey_ and _consumerSecret_. Spring XD will bind values for all of these properties as provided as options for each module instance. The options exposed for this module are defined in https://github.com/spring-projects/spring-xd/blob/master/extensions/spring-xd-extension-twitter/src/main/java/org/springframework/integration/x/twitter/TwitterSearchOptionsMetadata.java[TwitterSearchOptionsMetadata.java] 

For example, we can create two different streams, each using the _twittersearch_ source providing different option values.

    xd:> stream create --name tweettest --definition "twittersearch --query='java' | file"

and

    xd:> stream create --name tweettest2 --definition "twittersearch --query='spring' --language=en --consumerKey='mykey' --consumerSecret='mysecret' | file"

In addition to options, modules may reference Spring beans such that each module instance may inject a different implementation of a bean. The ability to deploy the same module definition with different configurations is only possible because each module is created in its own application context. This results in some very useful features, such as the ability to use standard bean ids such as _input_ and _output_ and simple property names without having to worry about naming collisions.

==== Stream Modules

Sources, processors, and sinks are built using http://spring.io/spring-integration[Spring Integration] and are typically perform a single task that they may be easily reused in streams. Alternately, a custom module may be required to perform a specific function, such as integration with a legacy service. In Spring Integration terms:

* A _source_ is a valid message flow that contains a direct channel named _output_ which is fed by an inbound adapter, either configured with a poller, or triggered by an event.

* A _processor_ is a valid message flow that contains a direct channel named _input_ and a subscribable channel named _output_ (direct or publish subscribe). It typically performs some type of transformation on the message, using its input channel's message to create a new message on its output channel.

* A _sink_ is a valid message flow that contains a direct channel named _input_ and an outbound adapter, or service activator used to provide the message to an external resource, HDFS for example.

For example, take a look at the https://github.com/spring-projects/spring-xd/blob/master/modules/source/file/config/file.xml[file source] which simply polls a directory using a file inbound adapter and https://github.com/spring-projects/spring-xd/blob/master/modules/sink/file/config/file.xml[file sink] which appends an incoming message payload to a file using a file outbound adapter. On the surface, there is nothing special about these components. They are plain old Spring XML bean definition files.

Upon closer inspection, you will notice that modules adhere to some important conventions. For one thing, the file name is the module name. Also note the input and output channels are always named  _input_ and _output_, in keeping with the KISS principle (let us know if you come up with some simpler names). These bean definitions are required to bind the module's channels to the Spring XD message transport.

Also observe the use of property placeholders with sensible defaults where possible.  For example, the file source requires a directory. An appropriate strategy is to define a common root path for XD input files (At the time of this writing it is `/tmp/xd/input/`. This is subject to change, but illustrates the point). A stream definition using the file source may specify the the directory name by providing a value for the _dir_ option. If not provided, it will default to the stream name, which is contained in the `xd.stream.name` property bound to the module by the Spring XD runtime, see https://github.com/spring-projects/spring-xd/blob/master/modules/source/file/config/file.properties[file source metadata]. By convention, Spring XD defined properties are prefixed with _xd_. The `module info` command illustrates this point:

----
xd:>module info --name source:file
Information about source module 'file':

  Option Name        Description                                                                  Default                          Type
  -----------------  ---------------------------------------------------------------------------  -------------------------------  --------
  dir                the absolute path to the directory to monitor for files                      /tmp/xd/input/${xd.stream.name}  String
  pattern            a filter expression (Ant style) to accept only files that match the pattern  *                                String
  preventDuplicates  whether to prevent the same file from being processed twice                  true                             boolean
  ref                set to true to output the File object itself                                 false                            boolean
  fixedDelay         the fixed delay polling interval specified in seconds                        5                                int
  outputType         how this module should emit messages it produces                             <none>                           MimeType
----

==== Placeholders available to all modules
Below is the list of all available `${xd.xxx}` keys that module authors may use in their declaration.

[NOTE]
.Using placeholders in stream definitions
====
One can also use the `${xd.xxx}` notation directly inside the DSL definition of a stream or a job. For example:
----
xd:>stream create foo --definition "http | filter --expression=\"'${xd.stream.name}'\" | log"
----
will only let messages that read "foo" pass through.
====

[options=header]
|======================
|Placeholder             |Context           |Meaning         
|`${xd.stream.name}`     |streams           |the name of the stream the module lives in    
|`${xd.job.name}`        |jobs              |the name of the job the module lives in    
|`${xd.module.name}`     |streams, jobs     |the technical name of the module    
|`${xd.module.type}`     |streams, jobs     |the type of the module    
|`${xd.module.index}`    |streams           |the 0-based position of the module inside the stream
|`${xd.container.id}`    |streams, jobs     |the generated unique id of the container the module is deployed in
|`${xd.container.host}`  |streams, jobs     |the hostname of the container the module is deployed in
|`${xd.container.pid}`   |streams, jobs     |the process id of the container the module is deployed in
|`${xd.container.ip}`    |streams, jobs     |the IP address of the container the module is deployed in
|`${xd.container.<foo>}` |streams, jobs     |the value of the custom attribute `<foo>` for the container
|======================

=== Registering a Module

Out of the box all modules are located in the  `xd/modules` directory where Spring XD is installed. The Module Registry organizes modules by  type in corresponding sub-directories, so you will see something like:

      modules/job
      modules/processor
      modules/sink
      modules/source

Spring XD provides a strategy interface https://github.com/SpringSource/spring-xd/blob/master/spring-xd-dirt/src/main/java/org/springframework/xd/dirt/module/ModuleRegistry.java[ModuleRegistry] used to locate a module of a given name and type. Currently Spring XD provides a ResourceModuleRegistry which is configured to locate modules in the following locations in this order:

* The file path given by `xd.module.home` (`${xd.home}/modules` by default)      
* `classpath:/modules/`  (Spring XD does not provide any module definitions here)
* The file path given by `xd.customModule.home` (not defined by default)

You can register a custom module by dropping your module files into the registry.  This can either be intalled as an expanded directory tree or an http://stackoverflow.com/questions/11947037/what-is-an-uber-jar[uberjar] compatible with the Spring Boot class loader, conforming to the following structure, and placed under the appropriate location for the module's type:

      <module_name>
      ├── config
      │   ├── <module_name>.properties
      │   └── <module_name>.xml (optional)
      ├── lib (optional)
      │   ├── <dependent libraries not already in Spring XD classpath (xd/lib)>
      │  

If installing a Spring Boot uberjar, the jar name is the module name:

    <module_type>
          ├── <module_name>.jar 


Where the module uberjar has an identical structure and may also contain local class files in the root, per the normal jar format:

      <module_name>.jar
      ├── config
      │   ├── <module_name>.properties
      │   └── <module_name>.xml (optional)
      ├── lib
      │   ├── <dependent libraries not already in Spring XD classpath (xd/lib)>
      │  

[NOTE]Currently, detecting an embedded version in the jar name, a la Maven, is not supported. `myModule-v1.jar` resolves the module name as `myModule-v1` 

[NOTE]If your custom module requires no additional dependencies, a normal jar with the `config` directory at the top level will work. If you require dependent jars they must be packaged without compression in order to work with the Spring Boot class loader. In this case, we recommended you use one of the available http://docs.spring.io/autorepo/docs/spring-boot/current/reference/html/build-tool-plugins.html[Spring Boot build plugins], the Maven http://maven.apache.org/plugins/maven-assembly-plugin/[assembly] plugin, or `jar -0` to build the uberjar. 

==== Custom Module Registry

If you prefer to use a separate location to install custom modules, you can set the externalized property `xd.customModule.home` in servers.yml.

==== Module Class Loading

Modules use a separate class loader that will first load classes from jars in the module's /lib (and any class files located in the module's root path). If not found, the class will be loaded from the parent ClassLoader that Spring XD normally uses (which includes everything under `$XD_HOME/lib`). Still, there are a couple of caveats to be aware of:

* Avoid putting into the `lib/` directory any jar files that are already in Spring XD's class path or you may end up with ClassCastExceptions or other class loading issues.

* Any class that is directly or indirectly referenced from the payload type of your messages (__i.e.__ any type in transit from module to module) must be referenced by both the producing and consuming modules and thus should be installed into xd/lib.

[[composing-modules]]
=== Composing Modules

As described above, a stream is defined as a sequence of modules, minimally a source module followed by a sink module. Sometimes streams may want share a common processing chain. For example, consider the following two streams:

    stream1 = http | filter --expression=payload.contains('foo') | file
    stream2 = file | filter --expression=payload.contains('foo') | file

Aside from the source, the two stream definitions are the same. Composite Modules are designed to avoid this type of duplication. The filter processor and file sink may be combined into a single composite module using the `module compose` shell command:

    xd:> module compose foo --definition "filter --expression=payload.contains('foo') | file"

Then, to verify the new module composition was successful, check if it exists:
----
xd:>module list
      Source              Processor           Sink                     Job
  ------------------  ------------------  -----------------------  ----------------
      file                aggregator          aggregate-counter        filejdbc
      gemfire             http-client         counter                  ftphdfs

                                   (....)

      trigger                                 splunk
      twittersearch                           tcp
      twitterstream                           throughput-sampler
      time                                (c) foo
----

Notice that the composed module shows up in the list of *sink* modules. That is because logically it acts as a sink: It provides an input channel (which is bridged to the filter processor's input channel), but it provides no output channel (since the file sink has no output). Also notice that the module has a small `(c)` prefixed to it, to indicate that it is a composed module.

If a module were composed of two processors, it would be classified as a processor:

    xd:> module compose myprocessor --definition "splitter | filter --expression=payload.contains('foo')"

If a module were composed of a source and a processor, it would be classified as a source:

   xd:> module compose mysource --definition "http | filter --expression=payload.contains('foo')"

Based on the logical type of the composed module, it may be used in a stream as if it were a simple module instance. For example, to redefine the two streams from the first problem case above, now that the "foo" sink module has been composed, you would issue the following shell commands:

    xd:> stream create httpfoo --definition "http | foo" --deploy
    xd:> stream create filefoo --definition "file --outputType=text/plain | foo"  --deploy

To test the "httpfoo" stream, try the following:

    xd:> http post --data hi
    xd:> http post --data hifoo

The first message should have been ignored due to the filter, but the second one should exist in the file:

    xd:> ! cat /tmp/xd/output/httpfoo.out
    command is:cat /tmp/xd/output/httpfoo.out
    hifoo

To test the "filefoo" stream, echo "foo" to a file in the /tmp/xd/input/filefoo directory, then verify:

    xd:> ! cat /tmp/xd/output/filefoo.out
    command is:cat /tmp/xd/output/filefoo.out
    foo

When you no longer need a composed module, you may delete it with the "module delete" command in the shell. However, if that composed module is currently being used by one or more streams, the deletion will fail as shown below:

    xd:> module delete --name sink:foo
    16:51:37,349  WARN Spring Shell client.RestTemplate:566 - DELETE request for "http://localhost:9393/modules/sink/foo" resulted in 500 (Internal Server Error); invoking error handler
    Command failed org.springframework.xd.rest.client.impl.SpringXDException: Cannot delete module sink:foo because it is used by [stream:filefoo, stream:httpfoo]

As you can see, the failure message shows which stream(s) depend upon the composed module you are trying to delete.

If you destroy both of those streams and try again, it will work:

    xd:> stream destroy --name filefoo
    Destroyed stream 'filefoo'
    xd:> stream destroy --name httpfoo
    Destroyed stream 'httpfoo'
    xd:> module delete --name sink:foo
    Successfully destroyed module 'foo' with type sink

When creating a module, if you duplicate the name of an existing module for the same type, you will receive an error.  In the example below the user tried to compose a tcp module, however one already exists:

[source,bash]
----
xd:>module compose tcp --definition "filter --expression=payload.contains('foo') | file"
14:52:27,781  WARN Spring Shell client.RestTemplate:566 - POST request for "http://ec2-50-16-24-31.compute-1.amazonaws.com:9393/modules" resulted in 409 (Conflict); invoking error handler
Command failed org.springframework.xd.rest.client.impl.SpringXDException: There is already a module named 'tcp' with type 'sink'
----

However, you can create a module for a given type even though a module of that name exists but as a different type.  For example: I can create a sink module named filter, even though a filter module exists already as a processor.

Finally, it's worth mentioning that in some cases duplication may be avoided by reusing an actual stream rather than a composed module. This is possible when named channels are used in the source and/or sink position of a stream definition. For example, the same overall functionality as provided by the two streams above could also be achieved as follows:

    xd:> stream create foofilteredfile --definition "queue:foo > filter --expression=payload.contains('foo') | file"
    xd:> stream create httpfoo --definition "http > queue:foo"
    xd:> stream create filefoo --definition "file > queue:foo"

This approach is more appropriate for use-cases where individual streams on either side of the named channel may need to be deployed or undeployed independently. Whereas the queue typed channel will load-balance across multiple downstream consumers, the "topic:" prefix may be used if broadcast behavior is needed instead. For more information about named channels, refer to the link:DSL-Reference#named-channels[Named Channels] section.

In addition, composite modules may increase performance. Each module within a stream represents a unit of deployment. Therefore, `stream1` ans `sream2`, defined above are comprised of three such units (the source, the processor, and the sink). In a singlenode runtime, creating a composite module won't make much of a difference since the communication between modules in this case already uses a bridge between in-memory channels. When deploying a stream to a distributed runtime environment, however, the communication between each module typically occurs via messaging middleware, as modules are, by default, distributed evenly among the available containers. At times a stream will perform better if adjacent modules are co-located and can avoid middleware "hops". In such cases, composing modules allows the composite module to behave as a single "black box." In other words, if "foo | bar" are composed to create a new module named "baz", the input and/or output to "baz" will still go over the middleware, but foo and bar will be co-located in a single container instance and wired to communicate via local memory.

[[module_info]]
=== Getting Information about Modules

To view the available modules use the the `module list` command.  Modules appearing with a `(c)` marker are composed modules.  For example:

----
xd:>module list
      Source              Processor           Sink                     Job
  ------------------  ------------------  -----------------------  ----------------
      file                aggregator          aggregate-counter        filejdbc
      gemfire             analytic-pmml       counter                  ftphdfs
      gemfire-cq          http-client         field-value-counter      hdfsjdbc
      http                bridge              file                     hdfsmongodb
      jms                 filter              gauge                    jdbchdfs
      mail                json-to-tuple       gemfire-json-server      filepollhdfs
      mqtt                object-to-json      gemfire-server
      post                script              jdbc
      reactor-syslog      splitter            mail
      reactor-tcp         transform           mqtt
      syslog-tcp      (c) myfilter            rich-gauge
      syslog-udp                              splunk
      tail                                    tcp
      tcp                                     throughput-sampler
      tcp-client                              avro
      trigger                                 hdfs
      twittersearch                           log
      twitterstream                           rabbit
      rabbit                                  router
      time
----

To get information about a particular module (such as what options it accepts), use the `module info --<module type>:<module name>` command. For example:

[source,bash]
----
xd:>module info --name source:file
Information about source module 'file':

  Option Name        Description                                                                  Default  Type
  -----------------  ---------------------------------------------------------------------------  -------  ---------
  dir                the absolute path to the directory to monitor for files                      <none>   String
  pattern            a filter expression (Ant style) to accept only files that match the pattern  *        String
  outputType         how this module should emit messages it produces                             <none>   MimeType
  preventDuplicates  whether to prevent the same file from being processed twice                  true     boolean
  ref                set to true to output the File object itself                                 false    boolean
  fixedDelay         the fixed delay polling interval specified in seconds                        5        int

----


[[module_values]]
=== How module options are resolved
As we've seen so far, a module is a re-usable piece of Spring Integration (or Spring Batch) software that can be dynamically configured thru the use of *module options*.

A module option is any value that the module author has deemed worthy of configuration at deployment time. Preferably, the module author will have provided link:ModuleOptionsMetadata#module-options-metadata[metadata] to describe the available options. This section explains how default values are computed for each module option.

In a nutshell, actual values are drawn from the following 3 sources, from most precedent to least precedent:

1. actual values in the stream definition (_e.g._ `--foo=bar`)
2. platform-wide defaults (appearing _e.g._ in .yml and .properties files, see below)
3. defaults the module author chose (see link:ModuleOptionsMetadata#module-options-metadata[metadata])

Going into more detail, the mid layer above (platform-wide defaults) will resolve like so, assuming option `<optionname>` of module `<modulename>` (which is of type `<moduletype>`):

a. a *system property* named `<moduletype>.<modulename>.<optionname>`
b. an *environment variable* named `<moduletype>.<modulename>.<optionname>` (or `<MODULETYPE>_<MODULENAME>_<OPTIONNAME>`)
c. a key named `<optionname>` in the *properties* file `<root>/<moduletype>/<modulename>/<modulename>.properties`
d. a key named `<moduletype>.<modulename>.<optionname>` in the *YaML* file `<root>/<module-config>.yml`

where 

`<root>`:: is the value of the `xd.module.config.location` system property (driven by the `XD_MODULE_CONFIG_LOCATION` env var when using the canonical Spring XD shell scripts). Defaults to `${xd.config.home}/modules/`
`<module-config>`:: is the value of the `xd.module.config.name` system property (driven by the `XD_MODULE_CONFIG_NAME` env var). Defaults to `xd-module-config`

Note that YaML is particularly well suited for hierarchical configuration, so for example, instead of

----
source.file.dir: foo
source.file.pattern: *.txt

source.http.port: 1234
----

one can write

[source,yaml]
----
source:
  file:
    dir: foo
    pattern: *.txt
  http:
    port: 1234
----

Note that options in the `.properties` files can reference values that appear in the `modules.yml` file (this makes sharing common configuration easy). Also, the values that are used to configure the server runtimes (in `servers.yml`) are visible to `modules.yml` and `.properties` file (but the inverse is _not_ true).
