=== Introduction

The XD runtime environment supports data ingestion by allowing users to define link:Streams#streams[streams]. Streams are composed of _modules_ which encapsulate a unit of work into a reusable component.

Modules are categorized by type, typically representing the role or function of the module. Current XD module types include _source_, _sink_, and _processor_ which indicate how they modules may be composed in a stream. Specifically, a source polls an external resource, or is triggered by an event and only provides an output. The first module in a stream is always a source. A processor performs some type of transformation or business logic and provides an input and one or more outputs. A sink provides only an input and outputs data to an external resource to terminate the stream.

XD comes with a number of modules used for assembling streams which perform common input and/or output operations with files, HDFS, http, twitter, syslog, GemFire, and more. Users can easily assemble these into streams to build complex big data applications without having to know the underlying Spring products on which XD is built.

However, if you are interested in extending XD with your own modules, some knowledge of Spring, Spring Integration, and Spring Batch is essential. The remainder of this document assumes the reader has some familiarity with these topics.

=== Creating a Module
This section provides details on how to write and register custom modules. For a quick start, dive into the examples of creating link:Creating-a-Source-Module#creating-a-source-module[source], link:Creating-a-Processor-Module#creating-a-processor-module[processor], and link:Creating-a-Sink-Module#creating-a-sink-module[sink] modules.

A https://github.com/SpringSource/spring-xd/blob/master/spring-xd-module/src/main/java/org/springframework/xd/module/ModuleDefinition.java[ModuleDefinition] has the following required attributes:

* name - the name of the component, normally a single word representing the purpose of the module. Examples are _file_, _http_, _syslog_.
* type - the module type, current XD module types include _source_, _sink_, and _processor_
* instance id - This represents a named instance of a module with a given name and type, with a specific configuration.

==== Modules and Spring
At the core, a module is any component that may be implemented using a Spring application context. In this respect, the concept may be extended for purposes other than data ingestion. The types mentioned above (source, processor,sink) are specific to XD and constructing streams. But other module types are envisioned.

A module is typically configured using property placeholders which are bound to the module's attributes. Attributes may be required or optional and this coincides with whether a default value is provided for the placeholder.

For example, here is part of the Spring configuration for a _twittersearch_ source that runs a query against Twitter:

[source,xml]
----
<beans>
  ...
  <int:inbound-channel-adapter id="results" auto-startup="false"
    ref="twitterSearchMessageSource" method="getTweets">
    <int:poller fixed-delay="${fixedDelay:5000}"/>
  </int:inbound-channel-adapter>

  <bean id="twitterSearchMessageSource"
    class="org.springframework.integration.x.twitter.TwitterSearchMessageSource">
    <constructor-arg ref="oauth2Template"/>
    <constructor-arg value="${query}"/>
  </bean>

  <bean id="oauth2Template" class="org.springframework.social.oauth2.OAuth2Template">
    <constructor-arg index="0" value="${consumerKey:${twitter.oauth.consumerKey}}"/>
    <constructor-arg index="1" value="${consumerSecret:${twitter.oauth.consumerSecret}}"/>
    <constructor-arg index="2" value="http://notused"/>
    <constructor-arg index="3" value="http://notused"/>
    <constructor-arg index="4" value="https://api.twitter.com/oauth2/token"/>
  </bean>
</beans>
----

Note the property placeholders for _query_, _fixedDelay_, _consumerKey_ and _consumerSecret_. The _query_ property defines no default value, so it is a required attribute for this module. _fixedDelay_ defaults to 5000, so it is an optional attribute. Note the defaults for _consumerKey_ and _consumerSecret_. The property names prefixed by _twitter_ are globally defined for the entire XD system in _config/twitter.properties_. So if the user does not specify a _consumerKey_ or _consumerSecret_ when creating the stream, XD's twitter configuration will be used instead.

The XD server will substitute values for all of these properties as configured for each module instance.  For example, we can create two streams each creating an instance of the _twittersearch_ module with a different configuration.

    xd:> stream create --name tweettest --definition "twittersearch --query='java' | file"

or

    xd:> stream create --name tweettest2 --definition "twittersearch --query-'java' --consumerKey='mykey' --consumerSecret='mysecret' | file"

In addition to properties, modules may reference Spring beans which are defined externally such that each module instance may inject a different implementation of a bean. The ability to configure each module instance differently is only possible if each module is created in its own application context. The module may be configured with a parent context, but this should be done with care. In the simplest case, the module context is completely separate. This results in some very useful features, such as being able to create multiple bean instances with the same id, possibly with different configurations. More generally, this allows modules to adhere to the KISS principle.

==== Integration Modules

In Spring Integration terms,

* A _source_ is a valid message flow that contains a direct channel named _output_ which is fed by an inbound adapter, either configured with a poller, or triggered by an event.

* A _processor_ is a valid message flow that contains a direct channel named _input_ and a subscribable channel named _output_ (direct or publish subscribe). It should perform some type of transformation on the message. (TBD: Describe multiple outputs, routing, etc.)

* A _sink_ is a valid message flow that contains a direct channel named _input_ and an outbound adapter, or service activator used to consume a message payload.

Modules of type source, processor, and sink are built with Spring Integration and are typically very fine-grained.

For example, take a look at the https://github.com/spring-projects/spring-xd/blob/master/modules/source/file/config/file.xml[file source] which simply polls a directory using a file inbound adapter and https://github.com/spring-projects/spring-xd/blob/master/modules/sink/file/config/file.xml[file sink] which appends incoming message payloads to a file using a file outbound adapter. On the surface, there is nothing special about these components. They are plain old Spring XML bean definition files.

Upon closer inspection, you will notice that modules adhere to some important conventions. For one thing, the file name is the module name. Also note the channels named  _input_ and _output_, in keeping with the KISS principle (let us know if you come up with some simpler names). These names are by convention what XD uses to discover a module's input and/or output channels which it wires together to compose streams. Another thing you will observe is the use of property placeholders with sensible defaults where possible.  For example, the file source requires a directory. An appropriate strategy is to define a common root path for XD input files (At the time of this writing it is /tmp/xd/input/. This is subject to change, but illustrates the point). An instance of this module may specify the directory by providing _name_ property. If not provided, it will default to the stream name, which is contained in the _xd.stream.name_ property defined by the XD runtime. By convention, XD defined properties are prefixed with _xd_

    directory="/tmp/xd/input/${name:${xd.stream.name}}"

=== Registering a Module

XD provides a strategy interface https://github.com/SpringSource/spring-xd/blob/master/spring-xd-dirt/src/main/java/org/springframework/xd/dirt/module/ModuleRegistry.java[ModuleRegistry] which it uses to find a module of a given name and type. Currently XD provides RedisModuleRegistry and FileModuleRegistry, The ModuleRegistry is a required component for the XD Server. By default the XD Server is configured with the FileModuleRegistry which looks for modules in `${xd.home:..}/modules`. Where `xd.home` is a Java System Property or may be passed as a command line argument to the container launcher. So out of the box, the modules are contained in the XD modules directory. The modules directory organizes module types in sub-directories. So you will see something like:

      modules/processor
      modules/sink
      modules/source

Using the default server configuration, you simply drop your module file into the modules directory and deploy a stream to the server.

==== Modules with isolated classpath

In addition to the simple format described above, where you would have a `foo` source module implemented as a `modules/source/foo.xml` file, there is also preliminary support for modules that wish to bring their own library dependencies, in an isolated fashion.

This is accomplished by creating a __folder__ named after your module name and moving the xml file to a `config` subdirectory. As an example, the `foo.xml` file would then reside in 

  modules/source/foo/config/foo.xml

Additional jar files can then be added to a sibling `lib` directory, like so:

  modules/source/foo/
                     config/
                            foo.xml
                     lib/
                         commons-foo.jar
                         foo-ext.jar

Classes will first be loaded from any of the aforementioned jar files and, only if they're not found will they be loaded from the parent, global ClassLoader that Spring XD normally uses. Still, there are a couple of caveats that one should be aware of:

1. refrain from putting into the `lib/` folder jar files that are also part of Spring XD, or you'll likely end up with ClassCastExceptions
2. any class that is directly or indirectly referenced from the payload type of your messages (__i.e.__ the types that transit from module to module) must not belong to a particular module `lib/` folder but should rather be loaded by the global Spring XD classloader

[[composing-modules]]
=== Composing Modules

As described above, a stream is defined as a sequence of modules, minimally a source module followed by a sink module. One or more processor modules may be added in between the source and sink, but they are not mandatory. Sometimes streams are similar for a subset of their modules. For example, consider the following two streams:

    stream1 = http | filter --expression=payload.contains('foo') | file
    stream2 = file | filter --expression=payload.contains('foo') | file

Other than the source module, the definitions of those two streams are the same. It would be better to avoid this degree of duplication. This is the first problem that composed modules address.

Each module within a stream represents a unit of deployment. Therefore, in each of the streams defined above, there would be 3 such units (the source, the processor, and the sink). In a singlenode runtime, it doesn't make much of a difference since the communication between each module would be a bridge between in-memory channels. When deploying a stream to a distributed runtime environment, however, the communication between each module occurs over messaging middleware. That decoupling between modules is useful in that it promotes loose-coupling and thus enables load-balancing and buffering of messages when the consuming module(s) are temporarily busy or down. Nevertheless, at times the individual module boundaries are more fine-grained than necessary for these middleware "hops". Overhead may be avoided by reducing the overall number of deployment units and therefore the number of hops. In such cases, it's convenient to be able to wrap multiple modules together so that they act as a single "black box" unit for deployment. In other words, if "foo | bar" are composed together as a new module named "baz", the input and/or output to "baz" would still occur as a hop over the middleware, but the communication from foo to bar would occur directly, in-process. This is the second problem that composed modules address.

Now let's look at an example. Returning to the two similar streams above, the filter processor and file sink could be combined into a single module. In the shell, the following command would take care of that:

    xd:> module compose foo --definition "filter --expression=payload.contains('foo') | file"

Then, to verify the new module composition was successful, check if it exists:

    xd:> module list --type sink
    Module Name          Module Type
    -------------------  -----------
    ...
    foo                  sink

Notice that the composed module shows up in the list of *sink* modules. That is because logically, it has the structure of a sink: it provides an input channel (which is bridged to the filter processor's input channel), but it provides no output channel (since the file sink has no output).

If a module were composed of two processors, it would be classified as a processor itself:

    xd:> module compose myprocessor --definition "splitter | filter --expression=payload.contains('foo')"

If a module were composed of a source and a processor, it would be classified as a source itself:

   xd:> module compose mysource --definition "http | filter --expression=payload.contains('foo')"

Based on the logical type of the composed module, it may be used in a stream as if it were a simple module instance. For example, to redefine the two streams from the first problem case above, now that the "foo" sink module has been composed, you would issue the following shell commands:

    xd:> stream create httpfoo --definition "http | foo" --deploy
    xd:> stream create filefoo --definition "file --outputType=text/plain | foo"  --deploy

To test the "httpfoo" stream, try the following:

    xd:> http post --data hi
    xd:> http post --data hifoo

The first message should have been ignored due to the filter, but the second one should exist in the file:

    xd:> ! cat /tmp/xd/output/httpfoo.out
    command is:cat /tmp/xd/output/httpfoo.out
    hifoo

To test the "filefoo" stream, echo "foo" to a file in the /tmp/xd/input/filefoo directory, then verify:

    xd:> ! cat /tmp/xd/output/filefoo.out
    command is:cat /tmp/xd/output/filefoo.out
    foo

When you no longer need a composed module, you may delete it with the "module delete" command in the shell. However, if that composed module is currently being used by one or more streams, the deletion will fail as shown below:

    xd:> module delete --name foo --type sink
    16:51:37,349  WARN Spring Shell client.RestTemplate:566 - DELETE request for "http://localhost:9393/modules/sink/foo" resulted in 500 (Internal Server Error); invoking error handler
    Command failed org.springframework.xd.rest.client.impl.SpringXDException: Cannot delete module sink:foo because it is used by [stream:filefoo, stream:httpfoo]

As you can see, the failure message shows which stream(s) depend upon the composed module you are trying to delete.

If you destroy both of those streams and try again, it will work:

    xd:> stream destroy --name filefoo
    Destroyed stream 'filefoo'
    xd:> stream destroy --name httpfoo
    Destroyed stream 'httpfoo'
    xd:> module delete --name foo --type sink
    Successfully destroyed module 'foo' with type sink

When creating a module, if you duplicate the name of an existing module for the same type, you will receive an error.  In the example below the user tried to compose a tcp module, however one already exists:

[source,bash]
----
xd:>module compose tcp --definition "filter --expression=payload.contains('foo') | file"
14:52:27,781  WARN Spring Shell client.RestTemplate:566 - POST request for "http://ec2-50-16-24-31.compute-1.amazonaws.com:9393/modules" resulted in 409 (Conflict); invoking error handler
Command failed org.springframework.xd.rest.client.impl.SpringXDException: There is already a module named 'tcp' with type 'sink'
----

However, you can create a module for a given type even though a module of that name exists but as a different type.  For example: I can create a sink module named filter, even though a filter module exists already as a processor.

Finally, it's worth mentioning that in some cases duplication may be avoided by reusing an actual stream rather than a composed module. That is possible when named channels are used in the source and/or sink position of a stream definition. For example, the same overall functionality as provided by the two streams above could also be achieved as follows:

    xd:> stream create foofilteredfile --definition "queue:foo > filter --expression=payload.contains('foo') | file"
    xd:> stream create httpfoo --definition "http > queue:foo"
    xd:> stream create filefoo --definition "file > queue:foo"

This approach is more appropriate for use-cases where individual streams on either side of the named channel may need to be deployed or undeployed independently. Whereas the queue typed channel will load-balance across multiple downstream consumers, the "topic:" prefix may be used if broadcast behavior is needed instead. For more information about named channels, refer to the link:DSL-Reference#named-channels[Named Channels] section.

[[module_info]]
=== Getting Information about Modules

To view the available modules use the the `module list` command.  Modules appearing with a `(c)` marker are composed modules.  For example:

----
xd:>module list
      Source              Processor           Sink                     Job
  ------------------  ------------------  -----------------------  ----------------
      file                aggregator          aggregate-counter        filejdbc
      gemfire             analytic-pmml       counter                  ftphdfs
      gemfire-cq          http-client         field-value-counter      hdfsjdbc
      http                bridge              file                     hdfsmongodb
      jms                 filter              gauge                    jdbchdfs
      mail                json-to-tuple       gemfire-json-server      filepollhdfs
      mqtt                object-to-json      gemfire-server
      post                script              jdbc
      reactor-syslog      splitter            mail
      reactor-tcp         transform           mqtt
      syslog-tcp      (c) myfilter            rich-gauge
      syslog-udp                              splunk
      tail                                    tcp
      tcp                                     throughput-sampler
      tcp-client                              avro
      trigger                                 hdfs
      twittersearch                           log
      twitterstream                           rabbit
      rabbit                                  router
      time
----

To get information about a particular module (such as what options it accepts), use the `module info --<module type>:<module name>` command. For example:

[source,bash]
----
xd:>module info --name source:file
Information about source module 'file':

  Option Name        Description                                                                  Default  Type
  -----------------  ---------------------------------------------------------------------------  -------  ---------
  dir                the absolute path to the directory to monitor for files                      <none>   String
  pattern            a filter expression (Ant style) to accept only files that match the pattern  *        String
  outputType         how this module should emit messages it produces                             <none>   MediaType
  preventDuplicates  whether to prevent the same file from being processed twice                  true     boolean
  ref                set to true to output the File object itself                                 false    boolean
  fixedDelay         the fixed delay polling interval specified in seconds                        5        int

----

To display the actual definition file of a module use the `module display --name <module type>:<module name>` command. For example:

[source,bash]
----
xd:>module display --name tcp --type source
Configuration file contents for module definition 'tcp' (source):

-------------------------------------------------------------------------------
...
    <int-ip:tcp-connection-factory id="connectionFactory"
        type="server"
        port="${port}"
        lookup-host="${reverseLookup}"
        so-timeout="${socketTimeout}"
        using-nio="${nio}"
        using-direct-buffers="${useDirectBuffers}"
        deserializer="${decoder}"/>

    <int-ip:tcp-inbound-channel-adapter id="adapter" channel="toString"
        auto-startup="false"
        connection-factory="connectionFactory"/>

    <int:transformer input-channel="toString" output-channel="output" expression="new String(payload, '${charset}')"/>

    <int:channel id="output"/>
...
----

[[module_values]]
=== How module options are resolved
As we've seen so far, a module is a re-usable piece of Spring Integration (or Spring Batch) software that can be dynamically configured thru the use of *module options*.

A module option is any value that the module author has deemed worthy of configuration at deployment time. Preferably, the module author will have provided link:ModuleOptionsMetadata#introduction[metadata] to describe the available options. This section explains how default values are computed for each module option.

In a nutshell, actual values are drawn from the following 3 sources, from most precedent to least precedent:

1. actual values in the stream definition (_e.g._ `--foo=bar`)
2. platform-wide defaults (appearing _e.g._ in .yml and .properties files, see below)
3. defaults the module author chose (see link:ModuleOptionsMetadata#introduction[metadata])

Going into more detail, the mid layer above (platform-wide defaults) will resolve like so, assuming option `<optionname>` of module `<modulename>` (which is of type `<moduletype>`):

a. a *system property* named `<moduletype>.<modulename>.<optionname>`
b. an *environment variable* named `<moduletype>.<modulename>.<optionname>` (or `<MODULETYPE>_<MODULENAME>_<OPTIONNAME>`)
c. a key named `<optionname>` in the *properties* file `<root>/<moduletype>/<modulename>/<modulename>.properties`
d. a key named `<moduletype>.<modulename>.<optionname>` in the *YaML* file `<root>/<module-config>.yml`

where 

`<root>`:: is the value of the `xd.module.config.location` system property (driven by the `XD_MODULE_CONFIG_LOCATION` env var when using the canonical Spring XD shell scripts). Defaults to `${xd.config.home}/modules/`
`<module-config>`:: is the value of the `xd.module.config.name` system property (driven by the `XD_MODULE_CONFIG_NAME` env var). Defaults to `xd-module-config`

Note that YaML is particularly well suited for hierarchical configuration, so for example, instead of

----
source.file.dir: foo
source.file.pattern: *.txt

source.http.port: 1234
----

one can write

[source,yaml]
----
source:
  file:
    dir: foo
    pattern: *.txt
  http:
    port: 1234
----
