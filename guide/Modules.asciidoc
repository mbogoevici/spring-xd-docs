=== Introduction

Spring XD supports data ingestion by allowing users to define link:Streams#streams[streams]. Streams are composed of _modules_ which encapsulate a unit of work into a reusable component.

Modules are categorized by type, typically representing the role or function of the module. Current Spring XD module types include `source`, `sink`, `processor`, and `job`. The type indicates how the modules may be composed in a stream, or used to deploy a batch job. Specifically, a source polls an external resource, or is triggered by an event and only provides an output. The first module in a stream must be a source. A processor performs some type of transformation or business logic on the message and requires both an input and output. A sink provides only an input and outputs data to an external resource to terminate the stream. A job module implements a Spring Batch job.

Spring XD comes with a number of modules useful for assembling streams which perform common input and/or output operations using files, HDFS, http, twitter, syslog, GemFire, and more. Users can easily assemble these modules into streams to build complex big data applications declaratively, without having to know the underlying Spring products on which Spring XD is built.

However, if you are interested in extending Spring XD with your own modules, some knowledge of Spring, Spring Integration, and Spring Batch is essential. The remainder of this document assumes the reader has some familiarity with these topics.

=== Creating a Module
This section provides details on how to write and register custom modules. For a quick start, dive into the examples of creating link:Creating-a-Source-Module#creating-a-source-module[source], link:Creating-a-Processor-Module#creating-a-processor-module[processor], and link:Creating-a-Sink-Module#creating-a-sink-module[sink] modules.

A https://github.com/SpringSource/spring-xd/blob/master/spring-xd-module/src/main/java/org/springframework/xd/module/ModuleDefinition.java[ModuleDefinition] has the following required attributes:

* name - the name of the component, normally a single word representing the purpose of the module. Examples are _file_, _http_, _syslog_.
* type - the module type, current XD module types include _source_, _sink_, and _processor_

==== Modules and Spring
At the core, a module is any component that may be implemented using a Spring application context. In this respect, the concept may be extended for purposes other than data ingestion. The types mentioned above (source, processor,sink) are specific to Spring XD and constructing streams. But other module types are envisioned.

A module is typically configured using property placeholders which are bound to the module's options. Options may be required or optional where optional properties define a default value in link:ModuleOptionsMetadata[Module Options Metadata]. Module options metadata may be provided in a properties file or a Java class.

For example, here is part of the Spring configuration for the _twittersearch_ source that runs a query against Twitter:

[source,xml]
----
<beans>

  <bean class="org.springframework.integration.x.twitter.TwitterSearchChannelAdapter">
    <constructor-arg ref="twitterTemplate"/>
    <property name="readTimeout" value="${readTimeout}"/>
    <property name="connectTimeout" value="${connectTimeout}"/>
    <property name="autoStartup" value="false"/>
    <property name="outputChannel" ref="output"/>
    <property name="query" value="${query}" />
    <property name="language" value="${language}" />
    <property name="geocode" value="${geocode}" />
    <property name="resultType" value="${resultType}"/>
    <property name="includeEntities" value="${includeEntities}"/>
  </bean>

  <bean id="twitterTemplate" class="org.springframework.social.twitter.api.impl.TwitterTemplate">
    <constructor-arg value="${consumerKey}"/>
    <constructor-arg value="${consumerSecret}"/>
  </bean>

  <int:channel id="output"/>

</beans>
----

Note the property placeholders such as _query_, _language_, _consumerKey_ and _consumerSecret_. Spring XD will substitute values for all of these properties as configured for each module instance. The options for this module are defined in https://github.com/spring-projects/spring-xd/blob/master/extensions/spring-xd-extension-twitter/src/main/java/org/springframework/integration/x/twitter/TwitterSearchOptionsMetadata.java[TwitterSearchOptionsMetadata.java] 

For example, we can create two different streams, each using the _twittersearch_ source with a different configuration.

    xd:> stream create --name tweettest --definition "twittersearch --query='java' | file"

and

    xd:> stream create --name tweettest2 --definition "twittersearch --query='spring' --language=en --consumerKey='mykey' --consumerSecret='mysecret' | file"

In addition to options, modules may reference Spring beans such that each module instance may inject a different implementation of a bean. The ability to deploy the same module definition with different configurations is only possible because each module is created in its own application context. This results in some very useful features, such as the ability to use standard bean ids such as _input_ and _output_ and simple property names without having to worry about naming collisions. Overall, this allows modules to adhere to the KISS principle.

==== Stream Modules

Sources, Processors, and Sinks are built using http://spring.io/spring-integration[Spring Integration] and are typically perform one small task so that they may be easily reused. In Spring Integration terms,

* A _source_ is a valid message flow that contains a direct channel named _output_ which is fed by an inbound adapter, either configured with a poller, or triggered by an event.

* A _processor_ is a valid message flow that contains a direct channel named _input_ and a subscribable channel named _output_ (direct or publish subscribe). It typically performs some type of transformation on the message, using the message contents to create a new message.

* A _sink_ is a valid message flow that contains a direct channel named _input_ and an outbound adapter, or service activator used to provide the message to an external resource, HDFS for example.

For example, take a look at the https://github.com/spring-projects/spring-xd/blob/master/modules/source/file/config/file.xml[file source] which simply polls a directory using a file inbound adapter and https://github.com/spring-projects/spring-xd/blob/master/modules/sink/file/config/file.xml[file sink] which appends an incoming message payload to a file using a file outbound adapter. On the surface, there is nothing special about these components. They are plain old Spring XML bean definition files.

Upon closer inspection, you will notice that modules adhere to some important conventions. For one thing, the file name is the module name. Also note the input and output channels are always named  _input_ and _output_, in keeping with the KISS principle (let us know if you come up with some simpler names). These names are required to bind these channels to the messaging transport.

Also observe the use of property placeholders with sensible defaults where possible.  For example, the file source requires a directory. An appropriate strategy is to define a common root path for XD input files (At the time of this writing it is /tmp/xd/input/. This is subject to change, but illustrates the point). A stream definition using the file source may specify the the directory name by providing a value for the _dir_ option. If not provided, it will default to the stream name, which is contained in the `xd.stream.name` property provided to the module by the Spring XD runtime, see https://github.com/spring-projects/spring-xd/blob/master/modules/source/file/config/file.properties[file source metadata]. By convention, XD defined properties are prefixed with _xd_. This can be seen when using the `module info` command:

----
xd:>module info --name source:file
Information about source module 'file':

  Option Name        Description                                                                  Default                          Type
  -----------------  ---------------------------------------------------------------------------  -------------------------------  --------
  dir                the absolute path to the directory to monitor for files                      /tmp/xd/input/${xd.stream.name}  String
  pattern            a filter expression (Ant style) to accept only files that match the pattern  *                                String
  preventDuplicates  whether to prevent the same file from being processed twice                  true                             boolean
  ref                set to true to output the File object itself                                 false                            boolean
  fixedDelay         the fixed delay polling interval specified in seconds                        5                                int
  outputType         how this module should emit messages it produces                             <none>                           MimeType
----

==== Placeholders available to all modules
Below is the list of all available `${xd.xxx}` keys that module authors may use in their declaration.

[NOTE]
.Using placeholders in stream definitions
====
One can also use the `${xd.xxx}` notation directly inside the DSL definition of a stream or a job. For example:
----
xd:>stream create foo --definition "http | filter --expression=\"'${xd.stream.name}'\" | log"
----
will only let messages that read "foo" pass through.
====

[options=header]
|======================
|Placeholder             |Context           |Meaning         
|`${xd.stream.name}`     |streams           |the name of the stream the module lives in    
|`${xd.job.name}`        |jobs              |the name of the job the module lives in    
|`${xd.module.name}`     |streams, jobs     |the technical name of the module    
|`${xd.module.type}`     |streams, jobs     |the type of the module    
|`${xd.module.index}`    |streams           |the 0-based position of the module inside the stream
|`${xd.container.id}`    |streams, jobs     |the generated unique id of the container the module is deployed in
|`${xd.container.host}`  |streams, jobs     |the hostname of the container the module is deployed in
|`${xd.container.pid}`   |streams, jobs     |the process id of the container the module is deployed in
|`${xd.container.ip}`    |streams, jobs     |the IP address of the container the module is deployed in
|`${xd.container.<foo>}` |streams, jobs     |the value of the custom attribute `<foo>` for the container
|======================

=== Registering a Module

Spring XD provides a strategy interface https://github.com/SpringSource/spring-xd/blob/master/spring-xd-dirt/src/main/java/org/springframework/xd/dirt/module/ModuleRegistry.java[ModuleRegistry] which it uses to find a module of a given name and type. Currently XD provides RedisModuleRegistry and FileModuleRegistry, The ModuleRegistry is a required component for the Spring XD runtime. By default the Spring XD is configured with the FileModuleRegistry which looks for modules in `${xd.home:..}/modules`. Where `xd.home` is set by the environment variable `XD_HOME` or passed as a Java System property to the container launcher, . So out of the box, the modules are contained in the xd/modules directory where Spring XD is installed. The modules directory organizes module types in sub-directories. So you will see something like:

      modules/processor
      modules/sink
      modules/source

To register a module simply drop your module files (XML configuration, options metadata, and any dependent jars that are not already on the Spring XD classpath) into the xd/modules directory.

==== Modules with isolated classpath

In addition to the simple format described above, where you would have a `foo` source module implemented as a `modules/source/foo.xml` file, there is also support for modules that have specific library dependencies.

This is accomplished by creating a __folder__ named after your module name and moving the xml file to a `config` subdirectory. As an example, the `foo.xml` file would then reside in 

  modules/source/foo/config/foo.xml

Additional jar files can then be added to a sibling `lib` directory, like so:

  modules/source/foo/
                     config/
                            foo.xml
                     lib/
                         commons-foo.jar
                         foo-ext.jar

Classes will first be loaded from any of the aforementioned jar files and, only if they're not found will they be loaded from the parent, global ClassLoader that Spring XD normally uses. Still, there are a couple of caveats that one should be aware of:

1. Refrain from putting into the `lib/` folder jar files that are also part of Spring XD, or you'll likely end up with ClassCastExceptions
2. Any class that is directly or indirectly referenced from the payload type of your messages (__i.e.__ the types that transit from module to module) must not belong to a particular module `lib/` folder but should rather be loaded by the global Spring XD classloader (installed into xd/lib).

[[composing-modules]]
=== Composing Modules

As described above, a stream is defined as a sequence of modules, minimally a source module followed by a sink module. One or more processor modules may be added in between the source and sink, but they are not mandatory. Sometimes streams share a common processing chain. For example, consider the following two streams:

    stream1 = http | filter --expression=payload.contains('foo') | file
    stream2 = file | filter --expression=payload.contains('foo') | file

Other than the source module, the definitions of these two streams are the same. Composite Modules are a good way to avoid this type of duplication. In addition, Composite modules are co-located in a single container and may communicate directly in memory.

Each module within a stream represents a unit of deployment. Therefore, in each of the streams defined above, there would be 3 such units (the source, the processor, and the sink). In a singlenode runtime, it doesn't make much of a difference since the communication between modules uses a bridge between in-memory channels. When deploying a stream to a distributed runtime environment, however, the communication between each module typically occurs over messaging middleware, as modules are distributed evenly among the available containers. At times a stream will perform better if adjacent modules are co-located and can avoid middleware "hops". In such cases, you may wrap multiple modules together so that they act as a single "black box." In other words, if "foo | bar" are composed together as a new module named "baz", the input and/or output to "baz" will still go over the middleware, but foo and bar will be co-located and communicate via a local memory.

Let's look at an example. Returning to the two similar streams above, the filter processor and file sink may be combined into a single module using the `module compose` shell command:

    xd:> module compose foo --definition "filter --expression=payload.contains('foo') | file"

Then, to verify the new module composition was successful, check if it exists:
----
xd:>module list
      Source              Processor           Sink                     Job
  ------------------  ------------------  -----------------------  ----------------
      file                aggregator          aggregate-counter        filejdbc
      gemfire             http-client         counter                  ftphdfs

                                   (....)

      trigger                                 splunk
      twittersearch                           tcp
      twitterstream                           throughput-sampler
      time                                (c) foo
----

Notice that the composed module shows up in the list of *sink* modules. That is because logically it acts as a sink: It provides an input channel (which is bridged to the filter processor's input channel), but it provides no output channel (since the file sink has no output). Also notice that the module has a small `(c)` prefixed to it, to indicate that it is a composed module.

If a module were composed of two processors, it would be classified as a processor:

    xd:> module compose myprocessor --definition "splitter | filter --expression=payload.contains('foo')"

If a module were composed of a source and a processor, it would be classified as a source:

   xd:> module compose mysource --definition "http | filter --expression=payload.contains('foo')"

Based on the logical type of the composed module, it may be used in a stream as if it were a simple module instance. For example, to redefine the two streams from the first problem case above, now that the "foo" sink module has been composed, you would issue the following shell commands:

    xd:> stream create httpfoo --definition "http | foo" --deploy
    xd:> stream create filefoo --definition "file --outputType=text/plain | foo"  --deploy

To test the "httpfoo" stream, try the following:

    xd:> http post --data hi
    xd:> http post --data hifoo

The first message should have been ignored due to the filter, but the second one should exist in the file:

    xd:> ! cat /tmp/xd/output/httpfoo.out
    command is:cat /tmp/xd/output/httpfoo.out
    hifoo

To test the "filefoo" stream, echo "foo" to a file in the /tmp/xd/input/filefoo directory, then verify:

    xd:> ! cat /tmp/xd/output/filefoo.out
    command is:cat /tmp/xd/output/filefoo.out
    foo

When you no longer need a composed module, you may delete it with the "module delete" command in the shell. However, if that composed module is currently being used by one or more streams, the deletion will fail as shown below:

    xd:> module delete --name sink:foo
    16:51:37,349  WARN Spring Shell client.RestTemplate:566 - DELETE request for "http://localhost:9393/modules/sink/foo" resulted in 500 (Internal Server Error); invoking error handler
    Command failed org.springframework.xd.rest.client.impl.SpringXDException: Cannot delete module sink:foo because it is used by [stream:filefoo, stream:httpfoo]

As you can see, the failure message shows which stream(s) depend upon the composed module you are trying to delete.

If you destroy both of those streams and try again, it will work:

    xd:> stream destroy --name filefoo
    Destroyed stream 'filefoo'
    xd:> stream destroy --name httpfoo
    Destroyed stream 'httpfoo'
    xd:> module delete --name sink:foo
    Successfully destroyed module 'foo' with type sink

When creating a module, if you duplicate the name of an existing module for the same type, you will receive an error.  In the example below the user tried to compose a tcp module, however one already exists:

[source,bash]
----
xd:>module compose tcp --definition "filter --expression=payload.contains('foo') | file"
14:52:27,781  WARN Spring Shell client.RestTemplate:566 - POST request for "http://ec2-50-16-24-31.compute-1.amazonaws.com:9393/modules" resulted in 409 (Conflict); invoking error handler
Command failed org.springframework.xd.rest.client.impl.SpringXDException: There is already a module named 'tcp' with type 'sink'
----

However, you can create a module for a given type even though a module of that name exists but as a different type.  For example: I can create a sink module named filter, even though a filter module exists already as a processor.

Finally, it's worth mentioning that in some cases duplication may be avoided by reusing an actual stream rather than a composed module. This is possible when named channels are used in the source and/or sink position of a stream definition. For example, the same overall functionality as provided by the two streams above could also be achieved as follows:

    xd:> stream create foofilteredfile --definition "queue:foo > filter --expression=payload.contains('foo') | file"
    xd:> stream create httpfoo --definition "http > queue:foo"
    xd:> stream create filefoo --definition "file > queue:foo"

This approach is more appropriate for use-cases where individual streams on either side of the named channel may need to be deployed or undeployed independently. Whereas the queue typed channel will load-balance across multiple downstream consumers, the "topic:" prefix may be used if broadcast behavior is needed instead. For more information about named channels, refer to the link:DSL-Reference#named-channels[Named Channels] section.

[[module_info]]
=== Getting Information about Modules

To view the available modules use the the `module list` command.  Modules appearing with a `(c)` marker are composed modules.  For example:

----
xd:>module list
      Source              Processor           Sink                     Job
  ------------------  ------------------  -----------------------  ----------------
      file                aggregator          aggregate-counter        filejdbc
      gemfire             analytic-pmml       counter                  ftphdfs
      gemfire-cq          http-client         field-value-counter      hdfsjdbc
      http                bridge              file                     hdfsmongodb
      jms                 filter              gauge                    jdbchdfs
      mail                json-to-tuple       gemfire-json-server      filepollhdfs
      mqtt                object-to-json      gemfire-server
      post                script              jdbc
      reactor-syslog      splitter            mail
      reactor-tcp         transform           mqtt
      syslog-tcp      (c) myfilter            rich-gauge
      syslog-udp                              splunk
      tail                                    tcp
      tcp                                     throughput-sampler
      tcp-client                              avro
      trigger                                 hdfs
      twittersearch                           log
      twitterstream                           rabbit
      rabbit                                  router
      time
----

To get information about a particular module (such as what options it accepts), use the `module info --<module type>:<module name>` command. For example:

[source,bash]
----
xd:>module info --name source:file
Information about source module 'file':

  Option Name        Description                                                                  Default  Type
  -----------------  ---------------------------------------------------------------------------  -------  ---------
  dir                the absolute path to the directory to monitor for files                      <none>   String
  pattern            a filter expression (Ant style) to accept only files that match the pattern  *        String
  outputType         how this module should emit messages it produces                             <none>   MimeType
  preventDuplicates  whether to prevent the same file from being processed twice                  true     boolean
  ref                set to true to output the File object itself                                 false    boolean
  fixedDelay         the fixed delay polling interval specified in seconds                        5        int

----


[[module_values]]
=== How module options are resolved
As we've seen so far, a module is a re-usable piece of Spring Integration (or Spring Batch) software that can be dynamically configured thru the use of *module options*.

A module option is any value that the module author has deemed worthy of configuration at deployment time. Preferably, the module author will have provided link:ModuleOptionsMetadata#introduction[metadata] to describe the available options. This section explains how default values are computed for each module option.

In a nutshell, actual values are drawn from the following 3 sources, from most precedent to least precedent:

1. actual values in the stream definition (_e.g._ `--foo=bar`)
2. platform-wide defaults (appearing _e.g._ in .yml and .properties files, see below)
3. defaults the module author chose (see link:ModuleOptionsMetadata#introduction[metadata])

Going into more detail, the mid layer above (platform-wide defaults) will resolve like so, assuming option `<optionname>` of module `<modulename>` (which is of type `<moduletype>`):

a. a *system property* named `<moduletype>.<modulename>.<optionname>`
b. an *environment variable* named `<moduletype>.<modulename>.<optionname>` (or `<MODULETYPE>_<MODULENAME>_<OPTIONNAME>`)
c. a key named `<optionname>` in the *properties* file `<root>/<moduletype>/<modulename>/<modulename>.properties`
d. a key named `<moduletype>.<modulename>.<optionname>` in the *YaML* file `<root>/<module-config>.yml`

where 

`<root>`:: is the value of the `xd.module.config.location` system property (driven by the `XD_MODULE_CONFIG_LOCATION` env var when using the canonical Spring XD shell scripts). Defaults to `${xd.config.home}/modules/`
`<module-config>`:: is the value of the `xd.module.config.name` system property (driven by the `XD_MODULE_CONFIG_NAME` env var). Defaults to `xd-module-config`

Note that YaML is particularly well suited for hierarchical configuration, so for example, instead of

----
source.file.dir: foo
source.file.pattern: *.txt

source.http.port: 1234
----

one can write

[source,yaml]
----
source:
  file:
    dir: foo
    pattern: *.txt
  http:
    port: 1234
----

Note that options in the `.properties` files can reference values that appear in the `modules.yml` file (this makes sharing common configuration easy). Also, the values that are used to configure the server runtimes (in `servers.yml`) are visible to `modules.yml` and `.properties` file (but the inverse is _not_ true).
