<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="generator" content="Asciidoctor 0.1.2">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <title>Introduction</title>
    
    
    <link rel="stylesheet" href="./asciidoctor.css">
    
    
    

  </head>
  <body class="article">
    
    <div id="header">
      
      
    </div>
    
    <div id="content">
<div class="sect2">
  <h3 id="_introduction">Introduction</h3>
<div class="paragraph">  
  <p>This section will cover the processors available out-of-the-box with Spring XD.  As a prerequisite, start the XD Container
as instructed in the <a href="Getting-Started#getting-started">Getting Started</a> page.</p>
</div><div class="paragraph">  
  <p>The Processors covered are</p>
</div><div class="ulist">
  
  <ul>
  
    <li>
      <p><a href="#filter">Filter</a></p>
      
    </li>
  
    <li>
      <p><a href="#json-value-filter">JSON Field Value Filter</a></p>
      
    </li>
  
    <li>
      <p><a href="#transform">Transform</a></p>
      
    </li>
  
    <li>
      <p><a href="#json-field-extractor">JSON Field Extractor</a></p>
      
    </li>
  
    <li>
      <p><a href="#script">Script</a></p>
      
    </li>
  
    <li>
      <p><a href="#splitter">Splitter</a></p>
      
    </li>
  
    <li>
      <p><a href="#aggregator">Aggregator</a></p>
      
    </li>
  
  </ul>
</div>
<div class="paragraph">  
  <p>See the section <a href="Creating-a-Processor-Module#creating-a-processor-module">Creating a Processor Module</a> for information on how to create custom processor modules.</p>
</div>
</div><div class="sect2">
  <h3 id="filter">Filter</h3>
<div class="paragraph">  
  <p>Use the filter module in a <a href="Streams#streams">stream</a> to determine whether a Message should be passed to the output channel.</p>
</div><div class="sect3">
  <h4 id="_filter_with_spel_expression">Filter with SpEL expression</h4>
<div class="paragraph">  
  <p>The simplest way to use the filter processor is to pass a SpEL expression when creating the stream. The expression should evaluate the message and return true or false.  For example:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name filtertest --definition "http | filter --expression=payload=='good' | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>This filter will only pass Messages to the log sink if the payload is the word "good". Try sending "good" to the HTTP endpoint and you should see it in the XD log:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; http post --target http://localhost:9000 --data "good"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>Alternatively, if you send the word "bad" (or anything else), you shouldn&#8217;t see the log entry.</p>
</div><div class="paragraph">  
  <p>As part of the SpEL expression you can make use of the pre-registered JSON Path function.  Here is some example usage</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>filter --expression=#jsonPath(payload,'$.entities.hashTags[*].text').contains('obama')</pre>
  </div>
</div>
<div class="paragraph">  
  <p>This is an example that is operating on a JSON payload of tweets as consumed from the twitter search module.</p>
</div>
</div><div class="sect3">
  <h4 id="_filter_with_groovy_script">Filter with Groovy Script</h4>
<div class="paragraph">  
  <p>For more complex filtering, you can pass the location of a Groovy script using the <em>script</em> attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the <em>properties-location</em> attribute. All properties in the file will be made available to the script as variables.</p>
</div><div class="paragraph">  
  <p>Note that an implicit variable named <em>payload</em> is available to give you access to the data contained in a message.</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name groovyfiltertest --definition "http --port=9001 | filter --script=custom-filter.groovy --properties-location=custom-filter.properties | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>By default, Spring XD will search the classpath for <em>custom-filter.groovy</em> and <em>custom-filter.properties</em>. You can place the script in <em>${xd.home}/modules/processor/scripts</em> and the properties file in <em>${xd.home}/config</em> to make them available on the classpath.  Alternatively, you can prefix the <em>script</em> and <em>properties-location</em> values with <em>file:</em> to load from the file system.</p>
</div>
</div>
</div><div class="sect2">
  <h3 id="json-value-filter">JSON Field Value Filter</h3>
<div class="paragraph">  
  <p>Use this filter to only pass messages to the output channel if they contain a specific JSON field matching a specific value.</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name jsonfiltertest --definition "http --port=9002 | json-field-value-filter --fieldName=firstName --fieldValue=John | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>This filter will only pass Messages to the log sink if the JSON payload contains the <em>firstName</em> "John". Try sending this payload to the HTTP endpoint and you should see it in the XD log:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; http post --target http://localhost:9002 --data "{\"firstName\":\"John\", \"lastName\":\"Smith\"}"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>Alternatively, if you send a different <em>firstName</em>, you shouldn&#8217;t see the log entry.</p>
</div>
</div><div class="sect2">
  <h3 id="transform">Transform</h3>
<div class="paragraph">  
  <p>Use the transform module in a <a href="Streams#streams">stream</a> to convert a Message&#8217;s content or structure.</p>
</div><div class="sect3">
  <h4 id="_transform_with_spel_expression">Transform with SpEL expression</h4>
<div class="paragraph">  
  <p>The simplest way to use the transform processor is to pass a SpEL expression when creating the stream. The expression should return the modified message or payload.  For example:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name transformtest --definition "http --port=9003 | transform --expression='FOO' | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>This transform will convert all message payloads to the word "FOO". Try sending something to the HTTP endpoint and you should see "FOO" in the XD log:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; http post --target http://localhost:9003 --data "some message"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>As part of the SpEL expression you can make use of the pre-registered JSON Path function.  The syntax is #jsonPath(payload,<em>&lt;json path expression&gt;</em>)</p>
</div>
</div><div class="sect3">
  <h4 id="_transform_with_groovy_script">Transform with Groovy Script</h4>
<div class="paragraph">  
  <p>For more complex transformations, you can pass the location of a Groovy script using the <em>script</em> attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the <em>properties-location</em> attribute. All properties in the file will be made available to the script as variables.</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name groovytransformtest --definition "http --port=9004 | transform --script=custom-transform.groovy --properties-location=custom-transform.properties | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>By default, Spring XD will search the classpath for <em>custom-transform.groovy</em> and <em>custom-transform.properties</em>. You can place the script in <em>${xd.home}/modules/processor/scripts</em> and the properties file in <em>${xd.home}/config</em> to make them available on the classpath.  Alternatively, you can prefix the <em>script</em> and <em>properties-location</em> values with <em>file:</em> to load from the file system.</p>
</div>
</div>
</div><div class="sect2">
  <h3 id="json-field-extractor">JSON Field Extractor</h3>
<div class="paragraph">  
  <p>This processor converts a JSON message payload to the value of a specific JSON field.</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name jsontransformtest --definition "http --port=9005 | json-field-extractor --fieldName=firstName | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>Try sending this payload to the HTTP endpoint and you should see just the value "John" in the XD log:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; http post --target http://localhost:9005 --data "{\"firstName\":\"John\", \"lastName\":\"Smith\"}"</pre>
  </div>
</div>

</div><div class="sect2">
  <h3 id="script">Script</h3>
<div class="paragraph">  
  <p>The script processor contains a <em>Service Activator</em> that invokes a specified Groovy script. This is a slightly more generic way to accomplish processing logic, as the provided script may simply terminate the stream as well as transform or filter Messages.</p>
</div><div class="paragraph">  
  <p>To use the module, pass the location of a Groovy script using the <em>location</em> attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the <em>properties-location</em> attribute. All properties in the file will be made available to the script as variables.</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name groovyprocessortest --definition "http --port=9006 | script --location=custom-processor.groovy --properties-location=custom-processor.properties | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>By default, Spring XD will search the classpath for <em>custom-processor.groovy</em> and <em>custom-processor.properties</em>. You can place the script in <em>${xd.home}/modules/processor/scripts</em> and the properties file in <em>${xd.home}/config</em> to make them available on the classpath.  Alternatively, you can prefix the <em>location</em> and <em>properties-location</em> values with <em>file:</em> to load from the file system.</p>
</div>
</div><div class="sect2">
  <h3 id="splitter">Splitter</h3>
<div class="paragraph">  
  <p>The splitter module builds upon the concept of the same name in Spring Integration and allows the splitting of a single message into several distinct messages.</p>
</div><div class="paragraph">  
  <p>The splitter module accepts the following options:</p>
</div>
<div class="dlist">
  
  <dl>
    
    <dt class="hdlist1">
      expression
    </dt>
    
    <dd>
      
      <p>a SpEL expression which should evaluate to an array or collection. Each element will then be emitted as a separate message <strong>(default: <code>payload</code>, which actually does not split, unless the message is already a collection)</strong></p>
      
      
    </dd>
    
    
  </dl>
</div>

<div class="paragraph">  
  <p>As part of the SpEL expression you can make use of the pre-registered JSON Path function.  The syntax is #jsonPath(payload,<em>&lt;json path expression&gt;</em>)2</p>
</div>
</div><div class="sect2">
  <h3 id="aggregator">Aggregator</h3>
<div class="paragraph">  
  <p>The aggregator module does the opposite of the splitter, and builds upon the concept of the same name found in Spring Integration. By default, it will consider all incoming messages from a stream to belong to the same group:</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; stream create --name aggregates --definition "http | aggregator --count=3 --aggregation=T(org.springframework.util.StringUtils).collectionToDelimitedString(#this.![payload],' ') | log"</pre>
  </div>
</div>
<div class="paragraph">  
  <p>This uses a SpEL expression that will basically concatenate all payloads together, inserting a space character in between. As such,</p>
</div><div class="literalblock">
  
  <div class="content monospaced">
    <pre>xd:&gt; http post --data Hello
xd:&gt; http post --data World
xd:&gt; http post --data !</pre>
  </div>
</div>
<div class="paragraph">  
  <p>would emit a single message whose contents is "Hello World !". This is because we set the aggregator release strategy to accumulate 3 messages.</p>
</div><div class="paragraph">  
  <p>The aggregator modules comes with many more options, as shown below:</p>
</div>
<div class="dlist">
  
  <dl>
    
    <dt class="hdlist1">
      correlation
    </dt>
    
    <dd>
      
      <p>a SpEL expression to be evaluated against all incoming message and that should evaluate to the "key" used to group messages together <strong>(default: <code>&lt;streamname&gt;</code>, which means that all messages from the same stream are actually considered correlated)</strong></p>
      
      
    </dd>
    
    
    <dt class="hdlist1">
      release
    </dt>
    
    <dd>
      
      <p>a SpEL expression to be evaluated against a group of messages accumulated so far (a collection) and that should return true when such a group is ready to be released. Using this overrides the <em>count</em> option. <strong>(default: use the <code>'count'</code> approach)</strong></p>
      
      
    </dd>
    
    
    <dt class="hdlist1">
      count
    </dt>
    
    <dd>
      
      <p>the number of messages to group together before emitting a group <strong>(default: <code>50</code>)</strong></p>
      
      
    </dd>
    
    
    <dt class="hdlist1">
      aggregation
    </dt>
    
    <dd>
      
      <p>a SpEL expression, to be evaluated against the list of accumulated messages. This should return what the new message will be made of. <strong>(default: <code>#this.![payload]</code>, which uses the list of message payloads to form the new message)</strong></p>
      
      
    </dd>
    
    
    <dt class="hdlist1">
      timeout
    </dt>
    
    <dd>
      
      <p>the delay (in milliseconds) after which messages should be released and aggregated, even though the completion criteria was not met. Due to the way this is implemented (see MessageGroupStoreReaper in the Spring Integration documentation), the actual observed delay may vary between <code>timeout</code> and <code>2xtimeout</code>. <strong>(default: <code>60000</code>, <em>i.e.</em> one minute)</strong></p>
      
      
    </dd>
    
    
  </dl>
</div>


</div>
    </div>
    
    <div id="footer">
      <div id="footer-text">
        
        Last updated 2013-11-13 18:03:41 EST
      </div>
    </div>
  </body>
</html>