=== Introduction
In this section we will show some variations on input sources.  As a prerequisite start the XD Container
as instructed in the link:Getting-Started#getting-started[Getting Started] page.

The Sources covered are

* <<http, HTTP>>
* <<tail, Tail>>
* <<file, File>>
* <<mail_source, Mail>>
* <<twittersearch, Twitter Search>>
* <<twitterstream, Twitter Stream>>
* <<gemfire-source, Gemfire>>
* <<gemfire-cq,Gemfire CQ>>
* <<syslog, Syslog>>
* <<tcp, TCP>> 
* <<tcp-client, TCP Client>> 
* <<reactor-ip, Reactor IP>> 
* <<jms, JMS>>
* <<rabbit, RabbitMQ>>
* <<time, Time>>
* <<mqtt, MQTT>>
* <<stdout, Stdout Capture>>

Future releases will provide support for other currently available Spring Integration Adapters.  For information on how to adapt an existing Spring Integration Adapter for use in Spring XD see the section link:Creating-a-Source-Module#creating-a-source-module[Creating a Source Module].

The following sections show a mix of Spring XD shell and plain Unix shell commands, so if you are trying them out, you should open two separate terminal prompts, one running the XD shell and one to enter the standard commands for sending HTTP data, creating directories, reading files and so on.

[[http]]
=== HTTP

To create a stream definition in the server using the XD shell

    xd:> stream create --name httptest --definition "http | file" --deploy

Post some data to the http server on the default port of 9000

     xd:> http post --target http://localhost:9000 --data "hello world"

See if the data ended up in the file

[source,bash]
----
$ cat /tmp/xd/output/httptest
----

To send binary data, set the `Content-Type` header to `application/octet-string`

    $ curl --data-binary @foo.zip -H'Content-Type: application-octet-string' http://localhost:9000

==== HTTP with options

The http source has one option

port:: The http port where data will be posted *(default: `9000`)*

Here is an example 

    xd:> stream create --name httptest9020 --definition "http --port=9020 | file" --deploy

Post some data to the new port

    xd:> http post --target http://localhost:9020 --data "hello world"

[source,bash]
----
$ cat /tmp/xd/output/httptest9020
----

[[tail]]
=== Tail

Make sure the default input directory exists

[source,bash]
----
$ mkdir -p /tmp/xd/input
----

Create an empty file to tail (this is not needed on some platforms such as Linux)

[source,bash]
----
$ touch /tmp/xd/input/tailtest  
----

To create a stream definition using the XD shell

    xd:> stream create --name tailtest --definition "tail | file" --deploy

Send some text into the file being monitored 

[source,bash]
----
$ echo blah >> /tmp/xd/input/tailtest
----

See if the data ended up in the file

[source,bash]
----
$ cat /tmp/xd/output/tailtest
----
==== Tail with options

The tail source has 3 options:

name:: the absolute path to the file to tail *(default: `/tmp/xd/input/<streamName>`)*
lines:: the number of lines from the end of an existing file to tail *(default: `0`)*
fileDelay:: on platforms that don't wait for a missing file to appear, how often (ms) to look for the file *(default: `5000`)*

Here is an example 

     xd:> stream create --name tailtest --definition "tail --name=/tmp/foo | file --name=bar" --deploy

[source,bash]
----
$ echo blah >> /tmp/foo

$ cat /tmp/xd/output/bar
----

==== Tail Status Events

Some platforms, such as linux, send status messages to `stderr`. The tail module sends these events to a logging adapter, at WARN level; for example...

----
[message=tail: cannot open `/tmp/xd/input/tailtest' for reading: No such file or directory, file=/tmp/xd/input/tailtest]
[message=tail: `/tmp/xd/input/tailtest' has become accessible, file=/tmp/xd/input/tailtest]
----

[[file]]
=== File

The file source provides the contents of a File as a byte array by default but may be configured to provide the file reference itself.    

To log the contents of a file create a stream definition using the XD shell

    xd:> stream create --name filetest --definition "file | log" --deploy

The file source by default will look into a directory named after the stream, in this case /tmp/xd/input/filetest

Note the above will log the raw bytes. For text files, it is normally desirable to output the contents as plain text. To do this, set the _outputType_ parameter: 

    xd:> stream create --name filetest --definition "file --outputType=text/plain | log" --deploy

For more details on the use of the _outputType_ parameter see link:Type-conversion#type-conversion[Type Conversion]

Copy a file into the directory `/tmp/xd/input/filetest` and observe its contents being logged in the XD Container.

==== File with options

The file source has 5 options

dir:: The absolute path to the directory to monitor for files *(default: `/tmp/xd/input/<streamName>`)*
preventDuplicates:: Default value is `true` to prevent the same file from being processed twice.
pattern:: A filter expression (Ant style) that accepts only files that match the pattern.
fixedDelay:: The fixed delay polling interval specified in seconds *(default: 5)*
ref:: Set to true to output the File object itself. This is useful in some cases in which the file contents are large and it would be more efficient to send the file path across the network than the contents. This option requires that the file be in a shared file system.

[[mail_source]]
=== Mail
Spring XD provides a source module for receiving emails, named `mail`. Depending on the protocol used, in can work by polling or receive mails as they become available.

Let's see an example:

  xd:> stream create --name mailstream --definition "mail --host=imap.gmail.com --username=your.user@gmail.com --password=secret | file" --deploy

Then send an email to yourself and you should see it appear inside a file at `/tmp/xd/output/mailstream`

The full list of options for the `mail` source is below:

protocol:: the protocol to use amongst pop3, pop3s, imap, imaps *(default: `imaps`)*
username:: the username to use to connect to the mail server *(no default)*
password:: the password to use to connect to the mail server *(no default)*
host:: the hostname of the mail server *(default: `localhost`)*
port:: the port of the mail server *(default: `25`)*
folder:: the folder to take emails from *(default: `INBOX`)*
markAsRead:: whether to mark emails as read once they've been fetched by the module *(default: `false`)*
delete:: whether to delete the emails once they've been fetched by the module *(default: `true`)*
usePolling:: whether to use polling or not (no-polling works with imap(s) only) *(default: `false`)*
fixedDelay:: the polling interval used for looking up messages, expressed in seconds. *(default: `60`)*
charset:: the charset used to transform the body of the incoming emails to Strings. *(default: `UTF-8`)*
expression:: a SpEL expression which filters which mail messages will be processed (non polling imap only) *(no default)*


[WARNING]
Of special attention are the `markAsRead` and `delete` options, which by default will *delete* the emails once they are consumed. It is hard to come up with a sensible default option for this (please refer to the Spring Integration documentation section on mail handling for a discussion about this), so just be aware that the default for XD is to delete incoming messages.


[[twittersearch]]
=== Twitter Search

The twittersearch source has four parameters

query:: The query that will be run against Twitter *(required)*  For information on how to construct a query, visit https://dev.twitter.com/docs/using-search[Using Search].
consumerKey:: An application consumer key issued by twitter
consumerSecret:: The secret corresponding to the `consumerKey`
fixedDelay:: The fixed delay polling interval specified in miliseconds *(default: 5000)*

To get a `consumerKey` and `consumerSecret` you need to register a twitter application. If you don't already have one set up, you can create an app at the https://dev.twitter.com/apps[Twitter Developers] site to get these credentials.

To create a stream definition in the server using the XD shell

    xd:> stream create --name springone2gx --definition "twittersearch --consumerKey=<your_key> --consumerSecret=<your_secret> --query='#springone2gx' | file" --deploy

Make sure the default output directory for the `file` sink exists

[source,bash]
----
$ mkdir -p /tmp/xd/output/
----

Let the twittersearch run for a little while and then check to see 
if some data ended up in the file

[source,bash]
----
$ cat /tmp/xd/output/springone2gx
----

TIP: For both `twittersearch` and `twitterstream` you can put the keys in a module properties file instead of supplying them in the stream definition. For twittersearch, the file would be `config/modules/source/twittersearch/twittersearch.properties`.

NOTE: `twittersearch` by default emits http://docs.spring.io/spring-social-twitter/docs/1.0.5.RELEASE/api/org/springframework/social/twitter/api/Tweet.html[Spring Social Tweet] objects. You may easily configure `twittersearch` to emit JSON by setting --output=application/json. This will cause XD to transform the objects JSON internally, resulting in properties corresponding to the Java type. This yields a format slightly different than the native Twitter JSON emitted by `twitterstream`. While logically identical, property names and types, notably dates, are different. Thus the JSON strings produced by `twittersearch` and `twitterstream` are generally incompatible.   

[[twitterstream]]
=== Twitter Stream

This source ingests data from Twitter's https://dev.twitter.com/docs/streaming-apis/streams/public[streaming] API. It uses the https://dev.twitter.com/docs/streaming-apis/streams/public[sample and filter] stream endpoints rather than the full "firehose" which needs special access. The endpoint used will depend on the parameters you supply in the stream definition (some are specific to the filter endpoint).

You need to supply all keys and secrets (both consumer and accessToken) to authenticate for this source, so it is easiest if you just add these to the `XD_HOME/config/modules/source/twitterstream/twitterstream.properties` file. Stream creation is then straightforward:

    xd:> stream create --name tweets --definition "twitterstream | file" --deploy

The parameters available are pretty much the same as those listed in the https://dev.twitter.com/docs/streaming-apis/parameters[API docs] and unless otherwise stated, the accepted formats are the same.

https://dev.twitter.com/docs/streaming-apis/parameters#delimited[delimited]:: set to `true` to get length delimiters in the stream data (defaults to `false`)

https://dev.twitter.com/docs/streaming-apis/parameters#stall_warnings[stallWarnings]:: set to `true` to enable stall warnings (defaults to `false`)

https://dev.twitter.com/docs/streaming-apis/parameters#filter_level[filterLevel]:: controls which tweets make it through to the stream (defaults to `null`)

https://dev.twitter.com/docs/streaming-apis/parameters#language[language]:: comma delimited set of languages to retain (defaults to `null`)

https://dev.twitter.com/docs/streaming-apis/parameters#follow[follow]:: comma delimited set of user ids whose tweets should be sent to the stream (defaults to `null`)

https://dev.twitter.com/docs/streaming-apis/parameters#track[track]:: which terms to look for in tweets (defaults to `null`)

https://dev.twitter.com/docs/streaming-apis/parameters#locations[locations]:: a comma-separated list of longitude,latitude pairs specifying a set of bounding boxes to filter Tweets (defaults to `null`)

NOTE: `twitterstream` emits JSON in a native Twitter format. This format is incompatible with content produced by `twittersearch` (see note above regarding `twittersearch`)

[[gemfire-source]]
=== GemFire
This source configures a cache and replicated region in the XD container process along with a Spring Integration GemFire inbound channel adapter, backed by a CacheListener that outputs messages triggered by an external entry event on the region. By default the payload contains the updated entry value, but may be controlled by passing in a SpEL expression that uses the http://www.vmware.com/support/developer/vfabric-gemfire/700-api/com/gemstone/gemfire/cache/EntryEvent.html[EntryEvent] as the evaluation context. 

==== Options

The Gemfire CacheListener source has the following options

regionName:: The name of the region for which events are to be monitored *(required, String)*
cacheEventExpression:: An optional SpEL expression referencing the event. *(default: `newValue`)*
host:: The host on which the GemFire server is running. *(default: `localhost`)*
port:: The port on which the GemFire server is running. *(default: `40404`)*

==== Example
Use of the gemfire source requires an external process that creates or updates entries in a GemFire region. Such events may trigger an XD process. For example, suppose a sales application creating and updating orders in a replicated GemFire region named `orders` . To trigger an XD stream, the XD container must join the GemFire distributed system and create a replica of the region, to which a cache listener is bound via the GemFire inbound channel adapter.

     xd:>stream create --name orderStream --definition "gemfire --regionName=orders | file --inputType=application/json"

In the above example, it is presumed the cache entries are Order POJOs. In this case, it may be convenient to convert to JSON before writing to the file. 

NOTE: In order to use locators you must add the `use-locator` to the active profile via server.yml or the spring.profiles_active environment variable.   

[[gemfire-cq]]
=== GemFire Continuous Query (CQ)
Continuous query allows client applications to create a GemFire query using Object Query Language(OQL) and register a CQ listener which subscribes to the query and is notified every time the query 's result set changes. The _gemfire_cq_ source registers a CQ which will post CQEvent messages to the stream. 

==== Launching the XD GemFire Server
This source requires a cache server to be running in a separate process and its host and port must be known (NOTE: GemFire locators are not supported yet). The XD distribution includes a GemFire server executable suitable for development and test purposes. This is a Java main class that runs with a Spring configured cache server. The configuration is passed as a command line argument to the server's main method. The configuration includes a cache server port and one or more configured region. XD includes a sample cache configuration called  https://github.com/SpringSource/spring-xd/blob/master/spring-xd-gemfire-server/config/cq-demo.xml[cq-demo]. This starts a server on port 40404 and creates a region named _Stocks_. A Logging cache listener is configured  for the region to log region events.  

Run Gemfire cache server by changing to the gemfire/bin directory and execute

[source,bash]
----
$ ./gemfire-server ../config/cq-demo.xml
----


==== Options

The qemfire-cq source has the following options

query:: The query string in Object Query Language(OQL) *(required, String)*
host:: The host on which the GemFire server is running. *(default: `localhost`)*
port:: The port on which the GemFire server is running. *(default: `40404`)*

Here is an example. Create two streams: One to write http messages to a Gemfire region named _Stocks_, and another to execute the CQ.

    xd:> stream create --name stocks --definition "http --port=9090 | gemfire-json-server --regionName=Stocks --keyExpression=payload.getField('symbol')" --deploy
    xd:> stream create --name cqtest --definition "gemfire-cq --query='Select * from /Stocks where symbol=''FAKE''' | file" --deploy

Now send some messages to the stocks stream.

     xd:> http post --target http://localhost:9090 --data {"symbol":"FAKE","price":73}
     xd:> http post --target http://localhost:9090 --data {"symbol":"FAKE","price":78}
     xd:> http post --target http://localhost:9090 --data {"symbol":"FAKE","price":80}

Please do not put spaces when separating the JSON key-value pairs, only a comma. 

The _cqtest_ stream is now listening for any stock quote updates for VMW. Presumably, another process is updating the cache. You may create a separate stream to test this (see https://github.com/SpringSource/spring-xd/wiki/GemfireServer[GemfireServer] for instructions).

As updates are posted to the cache you should see them captured in the output file:

[source,bash]
----
$ cat /tmp/xd/output/cqtest.out

{"symbol":"FAKE","price":73}
{"symbol":"FAKE","price":78}
{"symbol":"FAKE","price":80}
----

NOTE: In order to use locators you must add the `use-locator` to the active profile via server.yml or the spring.profiles_active environment variable.   

[[syslog]]
=== Syslog

Three syslog sources are provided: `reactor-syslog`, `syslog-udp`, and `syslog-tcp`. The reactor-syslog adapter uses tcp and builds upon the functionality available in the https://github.com/reactor/reactor[Reactor] project and provides improved throughput over the syslog-tcp adapter. They all support the following option:

port:: the port on which the system will listen for syslog messages *(default: `5140`)*

To create a stream definition (using shell command)

    xd:> stream create --name syslogtest --definition "reactor-syslog --port=5140 | file" --deploy

or

    xd:> stream create --name syslogtest --definition "syslog-udp --port=5140 | file" --deploy

or

    xd:> stream create --name syslogtest --definition "syslog-tcp --port=5140 | file" --deploy

(`--port` is not required when using the default `5140`)

Send a test message to the syslog

     logger -p local3.info -t TESTING "Test Syslog Message"

See if the data ended up in the file

[source,bash]
----
$ cat /tmp/xd/output/syslogtest
----

Refer to your syslog documentation to configure the syslog daemon to forward syslog messages to the stream; some examples are:

UDP - Mac OSX (syslog.conf) and Ubuntu (rsyslog.conf)

    *.*	@localhost:5140 

TCP - Ubuntu (rsyslog.conf)

    $ModLoad omfwd
    *.*	@@localhost:5140

Restart the syslog daemon after reconfiguring.


[[tcp]]
=== TCP
The `tcp` source acts as a server and allows a remote party to connect to XD and submit data over a raw tcp socket.

To create a stream definition in the server, use the following XD shell command

    xd:> stream create --name tcptest --definition "tcp | file" --deploy

This will create the default TCP source and send data read from it to the `tcptest` file.

TCP is a streaming protocol and some mechanism is needed to frame messages on the wire. A number of decoders are available, the default being 'CRLF' which is compatible with Telnet.

[source,bash]
----
$ telnet localhost 1234
Trying ::1...
Connected to localhost.
Escape character is '^]'.
foo
^]

telnet> quit
Connection closed.
----

See if the data ended up in the file

[source,bash]
----
$ cat /tmp/xd/output/tcptest
----

By default, the TCP module will emit a `byte[]`; to convert to a String, add `--outputType=text/plain` to the module definition.

==== TCP with options

The TCP source has the following options

port:: the port on which to listen *(default: `1234`)*
reverseLookup:: perform a reverse DNS lookup on the remote IP Address *(default: `false`)*
socketTimeout:: the timeout (ms) before closing the socket when no data received *(default: `120000`)*
nio:: whether or not to use NIO. NIO is more efficient when there are many connections. *(default: `false`)*
decoder:: how to decode the stream - see below. *(default: `CRLF`)*

==== Available Decoders

.Text Data

CRLF (default):: text terminated by carriage return (0x0d) followed by line feed (0x0a)
LF:: text terminated by line feed (0x0a)
NULL:: text terminated by a null byte (0x00)
STXETX:: text preceded by an STX (0x02) and terminated by an ETX (0x03)

.Text and Binary Data

RAW:: no structure - the client indicates a complete message by closing the socket
L1:: data preceded by a one byte (unsigned) length field (supports up to 255 bytes)
L2:: data preceded by a two byte (unsigned) length field (up to 2^16^-1 bytes)
L4:: data preceded by a four byte (signed) length field (up to 2^31^-1 bytes)


==== Examples

The following examples all use `echo` to send data to `netcat` which sends the data to the source.

The echo options `-en` allows echo to interpret escape sequences and not send a newline.

.CRLF Decoder

    xd:> stream create --name tcptest --definition "tcp | file" --deploy

This uses the default (CRLF) decoder and port 1234; send some data

[source,bash]
----
$ echo -en 'foobar\r\n' | netcat localhost 1234
----

See if the data ended up in the file

[source,bash]
----
$ cat /tmp/xd/output/tcptest
----

.LF Decoder

     xd:> stream create --name tcptest2 --definition "tcp --decoder=LF --port=1235 | file" --deploy

[source,bash]
----
$ echo -en 'foobar\n' | netcat localhost 1235
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest2
----

.NULL Decoder

     xd:> stream create --name tcptest3 --definition "tcp --decoder=NULL --port=1236 | file" --deploy

[source,bash]
----
$ echo -en 'foobar\x00' | netcat localhost 1236
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest3
----

.STXETX Decoder

     xd:> stream create --name tcptest4 --definition "tcp --decoder=STXETX --port=1237 | file" --deploy

[source,bash]
----
$ echo -en '\x02foobar\x03' | netcat localhost 1237
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest4
----

.RAW Decoder

     xd:> stream create --name tcptest5 --definition "tcp --decoder=RAW --port=1238 | file" --deploy

[source,bash]
----
$ echo -n 'foobar' | netcat localhost 1238
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest5
----

.L1 Decoder

     xd:> stream create --name tcptest6 --definition "tcp --decoder=L1 --port=1239 | file" --deploy

[source,bash]
----
$ echo -en '\x06foobar' | netcat localhost 1239
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest6
----

.L2 Decoder

     xd:> stream create --name tcptest7 --definition "tcp --decoder=L2 --port=1240 | file" --deploy

[source,bash]
----
$ echo -en '\x00\x06foobar' | netcat localhost 1240
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest7
----

.L4 Decoder

     xd:> stream create --name tcptest8 --definition "tcp --decoder=L4 --port=1241 | file" --deploy

[source,bash]
----
$ echo -en '\x00\x00\x00\x06foobar' | netcat localhost 1241
----

[source,bash]
----
$ cat /tmp/xd/output/tcptest8
----

==== Binary Data Example

     xd:> stream create --name tcptest9 --definition "tcp --decoder=L1 --port=1242 | file --binary=true" --deploy

Note that we configure the `file` sink with `binary=true` so that a newline is not appended.

[source,bash]
----
$ echo -en '\x08foo\x00bar\x0b' | netcat localhost 1242
----

[source,bash]
----
$ hexdump -C /tmp/xd/output/tcptest9
00000000  66 6f 6f 00 62 61 72 0b                           |foo.bar.|
00000008
----

==== Implementing a simple conversation
That "stimulus" counter concept bears some explanation. By default, the module will emit (at interval set by `fixedDelay`) an incrementing number, starting at 1. Given that the default is to use an `expression` of `payload.toString()`, this results in the module sending `1, 2, 3, ...` to the remote server.

By using another expression, or more certainly a `script`, one can implement a simple conversation, assuming it is time based. As an example, let's assume we want to join some kind of chat server where one first needs to authenticate, then specify which rooms to join. Lastly, all clients are supposed to send some keepalive commands to make sure that the connection is open.

The following groovy script could be used to that effect:

[source,groovy]
----
def commands = ['', // index 0 is not used
'LOGIN user=johndoe', // first command sent
'JOIN weather',
'JOIN news',
'JOIN gossip'
]


// payload will contain an incrementing counter, starting at 1
if (commands.size > payload)
  return commands[payload] + "\n"
else 
  return "PING\n"  // send keep alive after 4th 'real' command

----


[[tcp-client]]
=== TCP Client
The `tcp-client` source module uses raw tcp sockets, as does the `tcp` module but contrary to the `tcp` module, acts as a client. Whereas the `tcp` module will open a listening socket and wait for connections from a remote party, the `tcp-client` will initiate the connection to a remote server and emit as messages what that remote server sends over the wire. As an optional feature, the `tcp-client` can itself emit messages to the remote server, so that a simple conversation can take place.

==== TCP Client options
The following options are supported:

host:: the host to connect to *(default: `localhost`)*
port:: the port to connect to *(default: `1234`)*
reverseLookup:: whether to attempt to resolve the host address *(default: `false`)*
nio:: whether to use NIO *(default: `false`)*
encoder:: the encoder to use when sending messages *(default: `LF`, see <<tcp, TCP module>>)*
decoder:: the decoder to use when receiving messages *(default: `LF`, see <<tcp, TCP module>>)*
charset:: the charset to use when converting bytes to String *(default: `UTF-8`)*
bufferSize:: the size of the emitting/receiving buffers *(default: `2048`, _i.e._ 2KB)*
fixedDelay:: the rate at which 'stimulus' messages will be emitted *(default: `5` seconds)*
script:: reference to a script that should transform the counter stimulus to messages to send *(default: use `expression`)*
expression:: a SpEL expression to convert the counter stimulus to a message *(default: `payload.toString()`, _i.e._ emit "1", "2", "3", _etc._)*

[[reactor-ip]]
=== Reactor IP
The `reactor-ip` source acts as a server and allows a remote party to connect to XD and submit data over a raw TCP or UDP socket.  The reactor-ip source differs from the standard tcp source in that it is based on the https://github.com/reactor/reactor[Reactor Project] and can be configured to use the http://martinfowler.com/articles/lmax.html[LMAX Disruptor RingBuffer] library allowing for extremely high ingestion rates, e.g. ~ 1M/sec.

To create a stream definition use the following XD shell command

     xd:> stream create --name tcpReactor --definition "reactor-ip | file" --deploy

This will create the reactor TCP source and send data read from it to the file named tcpReactor.

The reactor-ip source has the following options

transport:: `tcp` or `udp` *(default: `tcp`)*
framing:: `linefeed` or `length`.  How to frame the data to tell individual messages apart. *(default: `linefeed`)*
lengthFieldLength:: Byte precision of the length field when using `length` framing. 2, 4 or 8.  *(default: `4`)*
codec:: How to decode the stream. Either bytes, string or syslog. *(default: `string`)*
dispatcher:: `ringBuffer`, `threadPoolExecutor`, `workQueue`, `sync`. *(default: `ringBuffer`)*
host:: the host to connect to *(default: `0.0.0.0`)*
port:: the port to connect to *(default: `3000`)*


[[rabbit]]
=== RabbitMQ

The "rabbit" source enables receiving messages from RabbitMQ.

The following example shows the default settings.

Configure a stream:

     xd:> stream create --name rabbittest --definition "rabbit | file --binary=true" --deploy

This receives messages from a queue named `rabbittest` and writes them to the default file sink (`/tmp/xd/output/rabbittest.out`). It uses the default RabbitMQ broker running on localhost, port 5672.

The queue(s) must exist before the stream is deployed. We do not create the queue(s) automatically. However, you can easily create a Queue using the RabbitMQ web UI. Then, using that same UI, you can navigate to the "rabbittest" Queue and publish test messages to it.

Notice that the `file` sink has `--binary=true`; this is because, by default, the data emitted by the source will be bytes. This can be modified by setting the `content_type` property on messages to `text/plain`. In that case, the source will convert the message to a `String`; you can then omit the `--binary=true` and the file sink will then append a newline after each message.

To destroy the stream, enter the following at the shell prompt:

    xd:> stream destroy --name rabbittest

==== RabbitMQ with Options

The RabbitMQ Source has the following options

username:: the username to connect to the RabbitMQ broker *(default: `guest`)*
password:: the password to connect to the RabbitMQ broker *(default: `guest`)*
host:: the host (or IP Address) to connect to *(default: `localhost`)*
port:: the port on the `host` *(default: `5672`)*
vhost:: the virtual host *(default: `/` unless)*
queues:: the queue(s) from which messages will be received; use a comma-delimited list to receive messages from multiple queues *(default: `<streamname>`)*

[[jms]]
=== JMS

The "jms" source enables receiving messages from JMS.

The following example shows the default settings.

Configure a stream:

     xd:> stream create --name jmstest --definition "jms | file" --deploy

This receives messages from a queue named `jmstest` and writes them to the default file sink (`/tmp/xd/output/jmstest`). It uses the default ActiveMQ broker running on localhost, port 61616.

To destroy the stream, enter the following at the shell prompt:

    xd:> stream destroy --name jmstest

To test the above stream, you can use something like the following...

[source,java]
----
public class Broker {

	public static void main(String[] args) throws Exception {
		BrokerService broker = new BrokerService();
		broker.setBrokerName("broker");
		String brokerURL = "tcp://localhost:61616";
		broker.addConnector(brokerURL);
		broker.start();
		ConnectionFactory cf = new ActiveMQConnectionFactory(brokerURL);
		JmsTemplate template = new JmsTemplate(cf);
		while (System.in.read() >= 0) {
			template.convertAndSend("jmstest", "testFoo");
		}
	}
}
----

and `tail -f /tmp/xd/output/jmstest`

Run this as a Java application; each time you hit <enter> in the console, it will send a message to queue `jmstest`.


==== JMS with Options

The JMS Source has the following options

provider:: the JMS provider *(default: `activemq`)*
destination:: the destination name (a `queue` by default) from which messages will be received *(default: `[stream name]`)*
pubSub:: when true, indicates that the destination is a `topic` *(default: `false`)*
durableSubScription:: when true, indicates the subscription to a topic is durable *(default: `false`)*
subscriptionName:: a name that will be assigned to the topic subscription *(default: `[none]`)*
clientId:: an identifier for the client, to be associated with a durable topic subscription *(default: `[none]`)*

Note: the selected broker requires an infrastructure configuration file `jms-<provider>-infrastructure-context.xml` in `modules/common`. This is used to declare any infrastructure beans needed by the provider. See the default (`jms-activemq-infrastructure-context.xml`) for an example. Typically, all that is required is a `ConnectionFactory`. The activemq provider uses a properties file `jms-activemq.properties` which can be found in the `config` directory. This contains the broker URL.

[[time]]
=== Time
The time source will simply emit a String with the current time every so often. It supports the following options:

fixedDelay:: how often to emit a message, expressed in seconds *(default: `1` second)*
format:: how to render the current time, using SimpleDateFormat *(default: `'yyyy-MM-dd HH:mm:ss'`)*


[[mqtt]]
=== MQTT
The mqtt source connects to an mqtt server and receives telemetry messages.

Configure a stream:

     xd:> stream create tcptest --definition "mqtt --url='tcp://localhost:1883' --topics='xd.mqtt.test' | log" --deploy

If you wish to use the MQTT Source defaults you can execute the command as follows:

     xd:> stream create tcptest --definition "mqtt | log" --deploy


==== Options

The defaults are set up to connect to the RabbitMQ MQTT adapter on localhost:

url:: location of the mqtt broker *(default: `tcp://localhost:1883`)*
clientId:: identifies the client *(default: `xd.mqtt.client.id.snk`)*
username:: the username to use when connecting to the broker *(default: `guest`)*
password:: the password to use when connecting to the broker *(default: `guest`)*
topics:: the topic(s) to which the source will subscribe *(default: `xd.mqtt.test`)*

[[stdout]]
=== Stdout Capture
There isn't actually a source named "stdin" but it is easy to capture stdin by redirecting it to a `tcp` source. For example if you wanted to capture the output of a command, you would first create the `tcp` stream, as above, using the appropriate sink for your requirements:

     xd:> stream create tcpforstdout --definition "tcp --decoder=LF | log" --deploy

You can then capture the output from commands using the `netcat` command:

[source,bash]
----
$ cat mylog.txt | netcat localhost 1234
----