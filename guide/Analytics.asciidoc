=== Introduction

Spring XD Analytics provides support for real-time analysis of data using metrics such as counters and gauges.  Spring XD intends to support a wide range of these metrics and analytical data structures as a general purpose class library that works with several backend storage technologies.

We'll look at the following metrics

* <<counter,Counter>>
* <<field-value-counter,Field Value Counter>>
* <<aggregate-counter, Aggregate Counter>>
* <<gauge,Gauge>>
* <<rich-gauge,Rich Gauge>>

An in memory implementation and a Redis implementation are provided in *Spring XD 1.0.0.M3*.  Other metrics that will be provided in a future release are Rate Counters and Histograms.

Metrics can be used directly in place of a sink just as if you were creating any other link:Streams#streams[stream], but you can also analyze data from an existing stream using a link:Taps#taps[tap]. We'll look at some examples of using metrics with taps in the following sections. As a prerequisite start the XD Container as instructed in the link:Getting-Started#getting-started[Getting Started] page. 

[[counter]]
=== Counter

A counter is a Metric that associates a unique name with a long value. It is primarily used for counting events triggered by incoming messages on a target stream. You create a counter with a unique name and optionally an initial value then set its value in response to incoming messages. The most straightforward use for counter is simply to count messages coming into the target stream. That is, its value is incremented on every message. This is exactly what the _counter_ module provided by Spring XD does. 

Here's an example:

Start by creating a data ingestion stream. Something like:

   xd:> stream create --name springtweets --definition "twittersearch --consumerKey=<your_key> --consumerSecret=<your_secret> --query=spring | file --dir=/tweets/"

Next, create a tap on the _springtweets_ stream that sets a message counter named _tweetcount_

   xd:> stream create --name tweettap --definition "tap:stream:springtweets > counter --name=tweetcount"

The results are written to redis under the key counter.${name}. To retrieve the count:
  
   $ redis-cli
   redis 127.0.0.1:6379> get counters.tweetcount

[[field-value-counter]]
=== Field Value Counter

A field value counter is a Metric used for counting occurrences of unique values for a named field in a message payload. XD Supports the following payload types out of the box:

* POJO (Java bean)
* Tuple
* JSON String

For example suppose a message source produces a payload with a field named _user_ :

[source,java]
class Foo {
   String user;
   public Foo(String user) {
       this.user = user;
   }
}

If the stream source produces messages with the following objects:

[source, java]
   new Foo("fred")
   new Foo("sue")
   new Foo("dave")
   new Foo("sue")

The field value counter on the field _user_ will contain:

    fred:1, sue:2, dave:1 

Multi-value fields are also supported. For example, if a field contains a list, each value will be counted once:
    
     users:["dave","fred","sue"]
     users:["sue","jon"]

The field value counter on the field _users_ will contain:

    dave:1, fred:1, sue:2, jon:1


field_value_counter has the following options:

fieldName:: The name of the field for which values are counted *(required)*
name:: A key used to access the counter values. *(default: stream name)*

To try this out, create a stream to ingest twitter feeds containing the word _spring_ and output to a file:

   xd:> stream create --name springtweets --definition "twittersearch --consumerKey=<your_key> --consumerSecret=<your_secret> --query=spring | file"

Now create a tap for a field value counter:

   xd:> stream create --name fromUserCount --definition "tap:stream:springtweets > field-value-counter --fieldName=fromUser"

The _twittersearch_ source produces JSON strings which contain the user id of the tweeter in the _fromUser_ field. The _field_value_counter_ sink parses the tweet and updates a field value counter named _fromUserCount_ in Redis. To view the counts:

   $ redis-cli
   redis 127.0.0.1:6379>zrange fieldvaluecounters.fromUserCount 0 -1 withscores 

[[aggregate-counter]]
=== Aggregate Counter

The aggregate counter differs from a simple counter in that it not only keeps a total value for the count, but also retains the total count values for each minute, hour day and month of the period for which it is run. The data can then be queried by supplying a start and end date and the resolution at which the data should be returned. 

Creating an aggregate counter is very similar to a simple counter. For example, to obtain an aggregate count for our spring tweets stream:
   
    xd:> stream create --name springtweets --definition "twittersearch --query=spring | file"

you'd simply create a tap which pipes the input to `aggregatecounter`:

   xd:> stream create --name tweettap --definition "tap:stream:springtweets > aggregatecounter --name=tweetcount"

The Redis back-end stores the aggregate counts in buckets prefixed with `aggregatecounters.${name}`. The rest of the string contains the date information. So for our `tweetcount` counter you might see something like the following keys appearing in Redis:

    redis 127.0.0.1:6379> keys aggregatecounters.tweetcount*
    1) "aggregatecounters.tweetcount"
    2) "aggregatecounters.tweetcount.years"
    3) "aggregatecounters.tweetcount.2013"
    4) "aggregatecounters.tweetcount.201307"
    5) "aggregatecounters.tweetcount.20130719"
    6) "aggregatecounters.tweetcount.2013071914"

The general format is
    
    . One total value
    . One years hash with a field per year eg. { 2010: value, 2011: value }
    . One hash per year with a field per month { 01: value, ...}
    . One hash per month with a field per day
    . One hash per day with a field per hour
    . One hash per hour with a field per minute


[[gauge]]
=== Gauge

A gauge is a Metric, similar to a counter in that it holds a single long value associated with a unique name. In this case the value can represent any numeric value defined by the application. 

The _gauge_ sink provided with XD stores expects a numeric value as a payload, typically this would be a decimal formatted string, and stores its values in Redis. The gauge includes the following attributes:

 name:: The name for the gauge *(default: `<streamname>`)*


Here is an example of creating a tap for a gauge:

==== Simple Tap Example

Create an ingest stream

    xd:> stream create --name test --definition "http --port=9090 | file"

Next create the tap:

    xd:> stream create --name simplegauge --definition "tap:stream:test > gauge"

Now Post a message to the ingest stream:

    xd:> http post --target http://localhost:9090 --data "10"

Check the gauge:

    $ redis-cli
    redis 127.0.0.1:6379> get gauges.simplegauge
    "10"

[[rich-gauge]]
=== Rich Gauge

A rich gauge is a Metric that holds a double value associated with a unique name. In addition to the value, the rich gauge keeps a running average, along with the minimum and maximum values and the sample count.

The _richgauge_ sink provided with XD expects a numeric value as a payload, typically this would be a decimal formatted string, and keeps its value in a store. The richgauge includes the following attributes:

 name:: The name for the gauge *(default: `<streamname>`)*
 alpha:: A smoothing factor between 0 and 1, that if set will compute an http://en.wikipedia.org/wiki/Exponential_smoothing[exponential moving average] *(default: `-1, simple average`)* 

When stored in Redis, the values are kept as a space delimited string, formatted as _value_ _alpha_ _mean_ _max_ _min_ _count_

Here are some examples of creating a tap for a rich gauge:

==== Simple Tap Example

Create an ingest stream

      xd:> stream create --name test --definition "http --port=9090 | file"

Next create the tap:

      xd:> stream create --name testgauge --definition "tap:stream:test > richgauge"

Now Post some messages to the ingest stream:

    xd:> http post --target http://localhost:9090 --data "10"
    xd:> http post --target http://localhost:9090 --data "13"
    xd:> http post --target http://localhost:9090 --data "16"

Check the gauge:

    $ redis-cli
    redis 127.0.0.1:6379> get richgauges.testgauge
    "16.0 -1 13.0 16.0 10.0 3"

==== Stock Price Example

In this example, we will track stock prices, which is a more practical example. The data is ingested as JSON strings like 

    {"symbol":"VMW","price":72.04}


Create an ingest stream

     xd:> stream create --name stocks --definition "http --port=9090 | file"

Next create the tap, using the json-field-extractor to extract the stock price from the payload: 

     xd:> stream create --name stockprice --definition "tap:stream:stocks > json-field-extractor --fieldName=price | richgauge"

Now Post some messages to the ingest stream:

    xd:> http post --target http://localhost:9090 --data "{"symbol":"VMW","price":72.04}"
    xd:> http post --target http://localhost:9090 --data "{"symbol":"VMW","price":72.06}"
    xd:> http post --target http://localhost:9090 --data "{"symbol":"VMW","price":72.08}"

Note: JSON fields should be separated by a comma without any spaces.

Check the gauge:

    $ redis-cli
    redis 127.0.0.1:6379> get richgauges.stockprice
    "72.08 -1 72.04 72.08 72.02 3"


==== Improved Stock Price Example

In this example, we will track stock prices for selected stocks. The data is ingested as JSON strings like 

    {"symbol":"VMW","price":72.04}
    {"symbol":"EMC","price":24.92}

The previous example would feed these prices to a single gauge. What we really want is to create a separate tap for each ticker symbol in which we are interested:

Create an ingest stream

     xd:> stream create --name stocks --definition "http --port=9090 | file"

Next create the taps, using the json-field-extractor to extract the stock price from the payload: 

     xd:> stream create --name vmwprice --definition "tap:stream:stocks > json-field-value-filter --fieldName=symbol --fieldValue=VMW | json-field-extractor --fieldName=price | richgauge"
     xd:> stream create --name emcprice --definition "tap:stream:stocks > json-field-value-filter --fieldName=symbol --fieldValue=EMC | json-field-extractor --fieldName=price | richgauge"

Now Post some messages to the ingest stream:

    xd:> http post --target http://localhost:9090 --data "{"symbol":"VMW","price":72.04}"
    xd:> http post --target http://localhost:9090 --data "{"symbol":"VMW","price":72.06}"
    xd:> http post --target http://localhost:9090 --data "{"symbol":"VMW","price":72.08}"

    xd:> http post --target http://localhost:9090 --data "{"symbol":"EMC","price":24.92}"
    xd:> http post --target http://localhost:9090 --data "{"symbol":"EMC","price":24.90}"
    xd:> http post --target http://localhost:9090 --data "{"symbol":"EMC","price":24.96}"

Check the gauge:

    $ redis-cli
    redis 127.0.0.1:6379> get richgauges.emcprice
    "24.96 -1 24.926666666666666 24.96 24.9 3"
    
    redis 127.0.0.1:6379> get richgauges.vmwprice
    "72.08 -1 72.04 72.08 72.02 3"

=== Accessing Analytics Data over the RESTful API

Spring XD has a discoverable RESTful API based on the Spring HATEAOS library.  You can discover the resources available by making a GET request on the root resource of the Admin server.  Here is an example where navigate down to find the data for a counter named 'httptap' that was created by these commands


[source,sh]
----
xd:>stream create --name httpStream --definition "http | file"
xd:>stream create --name httptap --definition "tap:stream:httpStream > counter"
xd:>http post --target http://localhost:9000 --data "helloworld"
----

The root resource returns 
[source,sh]
----
xd:>! wget  -q -S -O - http://localhost:9393/
{
  "links":[
    {},
    {
      "rel":"jobs",
      "href":"http://localhost:9393/jobs"
    },
    {
      "rel":"modules",
      "href":"http://localhost:9393/modules"
    },
    {
      "rel":"runtime/modules",
      "href":"http://localhost:9393/runtime/modules"
    },
    {
      "rel":"runtime/containers",
      "href":"http://localhost:9393/runtime/containers"
    },
    {
      "rel":"counters",
      "href":"http://localhost:9393/metrics/counters"
    },
    {
      "rel":"field-value-counters",
      "href":"http://localhost:9393/metrics/field-value-counters"
    },
    {
      "rel":"aggregate-counters",
      "href":"http://localhost:9393/metrics/aggregate-counters"
    },
    {
      "rel":"gauges",
      "href":"http://localhost:9393/metrics/gauges"
    },
    {
      "rel":"richgauges",
      "href":"http://localhost:9393/metrics/richgauges"
    }
  ]
}
----

Following the resource location for the counter

[source,sh]
----
xd:>! wget  -q -S -O - http://localhost:9393/metrics/counters
{
  "links":[

  ],
  "content":[
    {
      "links":[
        {
          "rel":"self",
          "href":"http://localhost:9393/metrics/counters/httptap"
        }
      ],
      "name":"httptap"
    }
  ],
  "page":{
    "size":0,
    "totalElements":1,
    "totalPages":1,
    "number":0
  }
}
----

And then the data for the counter itself
[source,sh]
----
xd:>! wget  -q -S -O - http://localhost:9393/metrics/counters/httptap
{
  "links":[
    {
      "rel":"self",
      "href":"http://localhost:9393/metrics/counters/httptap"
    }
  ],
  "name":"httptap",
  "value":2
}
----

