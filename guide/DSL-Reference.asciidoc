=== Introduction

Spring XD provides a DSL for defining a stream.  Over time the DSL is likely to evolve significantly as it gains the ability to define more and more sophisticated streams as well as the steps of a batch job.

=== Pipes and filters

A simple linear stream consists of a sequence of modules.  Typically an Input Source, (optional) Processing Steps, and an Output Sink.  As a simple example consider the collection of data from an HTTP Source writing to a File Sink. Using the DSL the stream description is:

  http | file

A stream that involves some processing:

  http | filter | transform | file

The modules in a stream definition are connected together using the pipe symbol `|`.  

=== Module parameters

Each module may take parameters. The parameters supported by a module are defined by the module implementation. As an example the `http` source module exposes `port` setting which allows the data ingestion port to be changed from the default value.

  http --port=1337

It is only necessary to quote parameter values if they contain spaces or the `|` character. Here the transform processor module is being passed a SpEL expression that will be applied to any data it encounters:

  transform --expression='new StringBuilder(payload).reverse()'

If the parameter value needs to embed a single quote, use two single quotes:

  // Query is: Select * from /Customers where name='Smith'
  scan --query='Select * from /Customers where name=''Smith'''


=== Named channels

Instead of a source or sink it is possible to use a named channel. Normally the modules in a stream are connected
by anonymous internal channels (represented by the pipes), but by using explicitly named channels it becomes 
possible to construct more sophisticated flows. In keeping with the unix theme, sourcing/sinking data from/to a particular channel uses the `>` character. A channel name is prefixed with a `:`

Here is an example that shows how you can use a named channel to share a data pipeline driven by different input sources.  

  :foo > file 

  http > :foo"

  time > :foo"

Now if you post data to the http source, you will see that data intermingled with the time value in the file.

The opposite case, he fanout of a message to multiple streams as well as support for routing messages to different streams based on message content is planned for a future release.


=== Tap

A Tap can be used to "listen in" to data from another stream and process the data in a separate stream. A tap can consume data from any point along the target stream's processing pipeline. The format of tap is:

  tap <stream>.<module>

For example, here is a stream called 'mystream':

  source | filter | transform | sink

The output of the filter step can be tapped:

  tap mystream.filter | sink2

If the module name is not specified, the tap is into the output of the source for that stream.

=== Labels

Labels provide a means to alias or group modules.  Labels are simply a name followed by a `:`
When used as an alias a label can provide a more descriptive name for a 
particular configuration of a module and possibly something easier to refer to in other streams.

  mystream = http | obfuscator: transform --expression=payload.replaceAll('password','*') | file
  tap mystream.obfuscator > log

A module may have multiple labels:

  mystream = http | foo: bar: transform --expression=payload.replaceAll('password','*') | file

When used for grouping a series of modules might share the same label:

  mystream = http | group1: filter | group1: transform | file

Referring to the label `group1` then effectively refers to all the labeled modules. This is not
yet exploited in XD but in future may be used for something like configuring deployment options:

  // Ensure all modules in group1 are on the same machine
  group1.colocation = true

