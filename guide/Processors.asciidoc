[[processors]]
ifndef::env-github[]
== Processors
endif::[]

=== Introduction
This section will cover the processors available out-of-the-box with Spring XD.  As a prerequisite, start the XD Container
as instructed in the link:Getting-Started#getting-started[Getting Started] page.

The Processors covered are

* <<filter, Filter>>
* <<transform, Transform>>
* <<script, Script>>
* <<splitter, Splitter>>
* <<aggregator, Aggregator>>
* <<http-clent, HTTP Client>>
* <<json-to-tuple, JSON to Tuple>>
* <<object-to-json, Object to JSON>>

See the section link:Creating-a-Processor-Module#creating-a-processor-module[Creating a Processor Module] for information on how to create custom processor modules.

[[filter]]
=== Filter
Use the filter module in a link:Streams#streams[stream] to determine whether a Message should be passed to the output channel.

//^processor.filter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.filter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$filter$$** $$processor$$ has the following options:

$$expression$$:: $$a SpEL expression to evaluate as a predicate$$ *($$String$$, no default)*
$$script$$:: $$location of a groovy script to use as a predicate to the filter$$ *($$String$$, no default)*
//$processor.filter

==== Filter with SpEL expression
The simplest way to use the filter processor is to pass a SpEL expression when creating the stream. The expression should evaluate the message and return true or false.  For example:

    xd:> stream create --name filtertest --definition "http | filter --expression=payload=='good' | log" --deploy

This filter will only pass Messages to the log sink if the payload is the word "good". Try sending "good" to the HTTP endpoint and you should see it in the XD log:

    xd:> http post --target http://localhost:9000 --data "good"

Alternatively, if you send the word "bad" (or anything else), you shouldn't see the log entry.

==== Filter using jsonPath evaluation

As part of the SpEL expression you can make use of the pre-registered JSON Path function.

This filter example shows to pass messages to the output channel if they contain a specific JSON field matching a specific value.

    xd:> stream create --name jsonfiltertest --definition "http --port=9002 | filter --expression=#jsonPath(payload,'$.firstName').contains('John') | log" --deploy

*Note:* There is no space between payload JSON and the jsonPath in the expression

This filter will only pass Messages to the log sink if the JSON payload contains the _firstName_ "John". Try sending this payload to the HTTP endpoint and you should see it in the XD log:

    xd:> http post --target http://localhost:9002 --data "{\"firstName\":\"John\", \"lastName\":\"Smith\"}"

Alternatively, if you send a different _firstName_, you shouldn't see the log entry.

Here is another example usage of filter

    filter --expression=#jsonPath(payload,'$.entities.hashtags[*].text').contains('obama')

This is an example that is operating on a JSON payload of tweets as consumed from the twitter search module.

==== Filter with Groovy Script
For more complex filtering, you can pass the location of a Groovy script using the _script_ attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the _properties-location_ attribute. All properties in the file will be made available to the script as variables.

Note that an implicit variable named _payload_ is available to give you access to the data contained in a message.

    xd:> stream create --name groovyfiltertest --definition "http --port=9001 | filter --script=custom-filter.groovy --properties-location=custom-filter.properties | log" --deploy

By default, Spring XD will search the classpath for _custom-filter.groovy_ and _custom-filter.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _script_ and _properties-location_ values with _file:_ to load from the file system.

[[transform]]
=== Transform
Use the transform module in a link:Streams#streams[stream] to convert a Message's content or structure.

//^processor.transform
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.transform' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$transform$$** $$processor$$ has the following options:

$$expression$$:: $$a SpEL expression used to transform messages$$ *($$String$$, default: `payload.toString()`)*
$$script$$:: $$reference to a script used to transform messages$$ *($$String$$, no default)*
//$processor.transform

==== Transform with SpEL expression
The simplest way to use the transform processor is to pass a SpEL expression when creating the stream. The expression should return the modified message or payload.  For example:

    xd:> stream create --name transformtest --definition "http --port=9003 | transform --expression='FOO' | log" --deploy

This transform will convert all message payloads to the word "FOO". Try sending something to the HTTP endpoint and you should see "FOO" in the XD log:

    xd:> http post --target http://localhost:9003 --data "some message"

As part of the SpEL expression you can make use of the pre-registered JSON Path function.  The syntax is #jsonPath(payload,'<json path expression>')

==== Transform with Groovy Script
For more complex transformations, you can pass the location of a Groovy script using the _script_ attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the _properties-location_ attribute. All properties in the file will be made available to the script as variables.

    xd:> stream create --name groovytransformtest --definition "http --port=9004 | transform --script=custom-transform.groovy --properties-location=custom-transform.properties | log" --deploy

By default, Spring XD will search the classpath for _custom-transform.groovy_ and _custom-transform.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _script_ and _properties-location_ values with _file:_ to load from the file system.

[[script]]
=== Script
The script processor contains a _Service Activator_ that invokes a specified Groovy script. This is a slightly more generic way to accomplish processing logic, as the provided script may simply terminate the stream as well as transform or filter Messages.

To use the module, pass the location of a Groovy script using the _location_ attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the _properties-location_ attribute. All properties in the file will be made available to the script as variables.

    xd:> stream create --name groovyprocessortest --definition "http --port=9006 | script --location=custom-processor.groovy --properties-location=custom-processor.properties | log" --deploy

By default, Spring XD will search the classpath for _custom-processor.groovy_ and _custom-processor.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _location_ and _properties-location_ values with _file:_ to load from the file system.

//^processor.script
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.script' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$script$$** $$processor$$ has the following options:

$$location$$:: $$the script to use (Spring resource, uses classpath: when no scheme given)$$ *($$String$$, no default)*
//$processor.script

[[splitter]]
=== Splitter
The splitter module builds upon the concept of the same name in Spring Integration and allows the splitting of a single message into several distinct messages.

//^processor.splitter
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.splitter' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$splitter$$** $$processor$$ has the following options:

$$expression$$:: $$a SpEL expression which would typically evaluate to an array or collection$$ *($$String$$, default: `payload`)*
//$processor.splitter

NOTE: The default value for `expression` is `payload`, which actually does not split, unless the message is already a collection.

As part of the SpEL expression you can make use of the pre-registered JSON Path function. The syntax is #jsonPath(payload,'<json path expression>')

==== Extract the value of a specific field

This splitter converts a JSON message payload to the value of a specific JSON field.

    xd:> stream create --name jsontransformtest --definition "http --port=9005 | splitter --expression=#jsonPath(payload,'$.firstName') | log" --deploy

Try sending this payload to the HTTP endpoint and you should see just the value "John" in the XD log:

    xd:> http post --target http://localhost:9005 --data '{"firstName":"John", "lastName":"Smith"}'


[[aggregator]]
=== Aggregator
The aggregator module does the opposite of the splitter, and builds upon the concept of the same name found in Spring Integration. By default, it will consider all incoming messages from a stream to belong to the same group:

  xd:> stream create --name aggregates --definition "http | aggregator --count=3 --aggregation=T(org.springframework.util.StringUtils).collectionToDelimitedString(#this.![payload],' ') | log" --deploy

This uses a SpEL expression that will basically concatenate all payloads together, inserting a space character in between. As such,

  xd:> http post --data Hello
  xd:> http post --data World
  xd:> http post --data !

would emit a single message whose contents is "Hello World !". This is because we set the aggregator release strategy to accumulate 3 messages.

//^processor.aggregator
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.aggregator' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$aggregator$$** $$processor$$ has the following options:

$$aggregation$$:: $$how to construct the aggregated message (SpEL expression against a collection of messages)$$ *($$String$$, default: `#this.![payload]`)*
$$correlation$$:: $$how to correlate messages (SpEL expression against each message)$$ *($$String$$, default: `'<stream name>'`)*
$$count$$:: $$the number of messages to group together before emitting a group$$ *($$int$$, default: `50`)*
$$dbkind$$:: $$which flavor of init scripts to use for the jdbc store (blank to attempt autodetection)$$ *($$String$$, no default)*
$$driverClassName$$:: $$the jdbc driver to use when using the jdbc store$$ *($$String$$, no default)*
$$hostname$$:: $$hostname of the redis instance to use as a store$$ *($$String$$, default: `localhost`)*
$$initializeDatabase$$:: $$whether to auto-create the database tables for the jdbc store$$ *($$boolean$$, default: `false`)*
$$password$$:: $$the password to use when using the jdbc or redis store$$ *($$String$$, default: ``)*
$$port$$:: $$port of the redis instance to use as a store$$ *($$int$$, default: `6379`)*
$$release$$:: $$when to release messages (SpEL expression against a collection of messages accumulated so far)$$ *($$String$$, no default)*
$$store$$:: $$the kind of store to use to retain messages$$ *($$StoreKind$$, default: `memory`, possible values: `memory,jdbc,redis`)*
$$timeout$$:: $$the delay (ms) after which messages should be released, even if the completion criteria is not met$$ *($$int$$, default: `50000`)*
$$url$$:: $$the jdbc url to connect to when using the jdbc store$$ *($$String$$, no default)*
$$username$$:: $$the username to use when using the jdbc store$$ *($$String$$, no default)*
//$processor.aggregator

[NOTE]
====
* Some of the options are only relevant when using a particular `store`
* The default `correlation` of `'<stream name>'` actually considers all messages to be correlated, since they all belong to the same stream.
* Using the `release` option overrides the `count` option (which is a simpler approach)
* The default for `aggregation` creates a new collection made of the payloads of the accumulated messages
* About the `timeout` option: due to the way it is implemented (see MessageGroupStoreReaper in the Spring Integration documentation), the actual observed delay may vary between `timeout` and `2xtimeout`.
====

[[http-client]]
=== HTTP Client
The `http-client` processor acts as a client that issues HTTP requests to a remote server, submitting the message payload it receices to that server and in turn emitting the response it receives to the next module down the line.

For example, the following command will result in an immediate fetching of earthquake data and it being logged in the container:
----
xd:>stream create earthquakes --definition "trigger | http-client --url='''http://earthquake.usgs.gov/earthquakes/feed/geojson/all/day''' --httpMethod=GET | log" --deploy
----

[NOTE]
====
Please be aware that the `url` option above is actually a SpEL expression, hence the triple quotes. If you'd like to learn more about quotes, please read link:DSL-Reference#dsl-quotes-escaping[the relevant documentation].
====

//^processor.http-client
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.http-client' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$http-client$$** $$processor$$ has the following options:

$$charset$$:: $$the charset to use when in the Content-Type header when emitting Strings$$ *($$String$$, default: `UTF-8`)*
$$httpMethod$$:: $$the http method to use when performing the request$$ *($$HttpMethod$$, default: `POST`, possible values: `OPTIONS,GET,HEAD,POST,PUT,PATCH,DELETE,TRACE,CONNECT`)*
$$mappedRequestHeaders$$:: $$request message header names to be propagated to/from the adpater/gateway$$ *($$String$$, default: `HTTP_REQUEST_HEADERS`)*
$$mappedResponseHeaders$$:: $$response message header names to be propagated from the adpater/gateway$$ *($$String$$, default: `HTTP_RESPONSE_HEADERS`)*
$$replyTimeout$$:: $$the amount of time to wait (ms) for a response from the remote server$$ *($$int$$, default: `0`)*
$$url$$:: $$the url to perform an http request on$$ *($$String$$, no default)*
//$processor.http-client

[[json-to-tuple]]
=== JSON to Tuple
The `json-to-tuple` processor is able to transform a String representation of some JSON map into a link:Tuples#tuples[Tuple].

Here is a simple example:
----
xd:>stream create tuples --definition "http | json-to-tuple | transform --expression='payload.firstName + payload.lastName' | log" --deploy

xd:>http post --data '{"firstName": "Spring", "lastName": "XD"}'
----

[NOTE]
====
Transformation to Tuple can be used as an alternative or in addition of link:Type-conversion#type-conversion[Type Conversion], depending on your usecase.
====

//^processor.json-to-tuple
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.json-to-tuple' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$json-to-tuple$$** $$processor$$ has no particular option (in addition to options shared by all modules)

//$processor.json-to-tuple

[[object-to-json]]
=== Object to JSON
The `object-to-json` processor can be used to convert any java Objec to a JSON String.

In the following example, notice how the collection of three elements is transformed to JSON (in particular, the three Strings are surrounded by quotes):

----
xd:>stream create json --deploy --definition "http | aggregator --count | object-to-json | log"

xd:>http post --data hello
xd:>http post --data world
xd:>http post --data !
----

results in `["hello", "world", "!"]` appearing in the log.

//^processor.object-to-json
// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$processor.object-to-json' TAG
// THIS SNIPPET HAS BEEN GENERATED BY ModuleOptionsReferenceDoc AND MANUAL EDITS WILL BE LOST
The **$$object-to-json$$** $$processor$$ has no particular option (in addition to options shared by all modules)

//$processor.object-to-json
