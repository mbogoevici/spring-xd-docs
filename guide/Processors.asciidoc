=== Introduction
This section will cover the processors available out-of-the-box with Spring XD.  As a prerequisite, start the XD Container
as instructed in the link:Getting-Started#getting-started[Getting Started] page.

The Processors covered are

* <<filter, Filter>>
* <<json-value-filter, JSON Field Value Filter>>
* <<transform, Transform>>
* <<json-field-extractor, JSON Field Extractor>>
* <<script, Script>>
* <<splitter, Splitter>>
* <<aggregator, Aggregator>>

See the section link:Creating-a-Processor-Module#creating-a-processor-module[Creating a Processor Module] for information on how to create custom processor modules.

[[filter]]
=== Filter
Use the filter module in a link:Streams#streams[stream] to determine whether a Message should be passed to the output channel.

==== Filter with SpEL expression
The simplest way to use the filter processor is to pass a SpEL expression when creating the stream. The expression should evaluate the message and return true or false.  For example:

    xd:> stream create --name filtertest --definition "http | filter --expression=payload=='good' | log"

This filter will only pass Messages to the log sink if the payload is the word "good". Try sending "good" to the HTTP endpoint and you should see it in the XD log:

    xd:> http post --target http://localhost:9000 --data "good"

Alternatively, if you send the word "bad" (or anything else), you shouldn't see the log entry.

==== Filter with Groovy Script
For more complex filtering, you can pass the location of a Groovy script using the _script_ attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the _properties-location_ attribute. All properties in the file will be made available to the script as variables.

    xd:> stream create --name groovyfiltertest --definition "http --port=9001 | filter --script=custom-filter.groovy --properties-location=custom-filter.properties | log"

By default, Spring XD will search the classpath for _custom-filter.groovy_ and _custom-filter.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _script_ and _properties-location_ values with _file:_ to load from the file system.

[[json-value-filter]]
=== JSON Field Value Filter
Use this filter to only pass messages to the output channel if they contain a specific JSON field matching a specific value.

    xd:> stream create --name jsonfiltertest --definition "http --port=9002 | json-field-value-filter --fieldName=firstName --fieldValue=John | log"

This filter will only pass Messages to the log sink if the JSON payload contains the _firstName_ "John". Try sending this payload to the HTTP endpoint and you should see it in the XD log:

    xd:> http post --target http://localhost:9002 --data "{\"firstName\":\"John\", \"lastName\":\"Smith\"}"

Alternatively, if you send a different _firstName_, you shouldn't see the log entry.

[[transform]] 
=== Transform
Use the transform module in a link:Streams#streams[stream] to convert a Message's content or structure.

==== Transform with SpEL expression
The simplest way to use the transform processor is to pass a SpEL expression when creating the stream. The expression should return the modified message or payload.  For example:

    xd:> stream create --name transformtest --definition "http --port=9003 | transform --expression='FOO' | log"

This transform will convert all message payloads to the word "FOO". Try sending something to the HTTP endpoint and you should see "FOO" in the XD log:

    xd:> http post --target http://localhost:9003 --data "some message"

==== Transform with Groovy Script
For more complex transformations, you can pass the location of a Groovy script using the _script_ attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the _properties-location_ attribute. All properties in the file will be made available to the script as variables.

    xd:> stream create --name groovytransformtest --definition "http --port=9004 | transform --script=custom-transform.groovy --properties-location=custom-transform.properties | log"

By default, Spring XD will search the classpath for _custom-transform.groovy_ and _custom-transform.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _script_ and _properties-location_ values with _file:_ to load from the file system.

[[json-field-extractor]]
=== JSON Field Extractor
This processor converts a JSON message payload to the value of a specific JSON field.

    xd:> stream create --name jsontransformtest --definition "http --port=9005 | json-field-extractor --fieldName=firstName | log"

Try sending this payload to the HTTP endpoint and you should see just the value "John" in the XD log:

    xd:> http post --target http://localhost:9005 --data "{\"firstName\":\"John\", \"lastName\":\"Smith\"}"

[[script]]
=== Script
The script processor contains a _Service Activator_ that invokes a specified Groovy script. This is a slightly more generic way to accomplish processing logic, as the provided script may simply terminate the stream as well as transform or filter Messages. 

To use the module, pass the location of a Groovy script using the _location_ attribute. If you want to pass variable values to your script, you can optionally pass the path to a properties file using the _properties-location_ attribute. All properties in the file will be made available to the script as variables.

    xd:> stream create --name groovyprocessortest --definition "http --port=9006 | script --location=custom-processor.groovy --properties-location=custom-processor.properties | log"

By default, Spring XD will search the classpath for _custom-processor.groovy_ and _custom-processor.properties_. You can place the script in _${xd.home}/modules/processor/scripts_ and the properties file in _${xd.home}/config_ to make them available on the classpath.  Alternatively, you can prefix the _location_ and _properties-location_ values with _file:_ to load from the file system.

[[splitter]]
=== Splitter
The splitter module builds upon the concept of the same name in Spring Integration and allows the splitting of a single message into several distinct messages.

The splitter module accepts the following options:

expression:: a SpEL expression which should evaluate to an array or collection. Each element will then be emitted as a separate message *(default: `payload`, which actually does not split, unless the message is already a collection)*

[[aggregator]]
=== Aggregator
The aggregator module does the opposite of the splitter, and builds upon the concept of the same name found in Spring Integration. By default, it will consider all incoming messages from a stream to belong to the same group:

  xd:> stream create --name aggregates --definition "http | aggregator --count=3 --aggregation=T(org.springframework.util.StringUtils).collectionToDelimitedString(#this.![payload],' ') | log"

This uses a SpEL expression that will basically concatenate all payloads together, inserting a space character in between. As such,

  xd:> http post --data Hello
  xd:> http post --data World
  xd:> http post --data !

would emit a single message whose contents is "Hello World !". This is because we set the aggregator release strategy to accumulate 3 messages.

The aggregator modules comes with many more options, as shown below:

correlation:: a SpEL expression to be evaluated against all incoming message and that should evaluate to the "key" used to group messages together *(default: `<streamname>`, which means that all messages from the same stream are actually considered correlated)*
release:: a SpEL expression to be evaluated against a group of messages accumulated so far (a collection) and that should return true when such a group is ready to be released. Using this overrides the 'count' option. *(default: use the `'count'` approach)*
count:: the number of messages to group together before emitting a group *(default: `50`)*
aggregation:: a SpEL expression, to be evaluated against the list of accumulated messages. This should return what the new message will be made of. *(default: `#this.![payload]`, which uses the list of message payloads to form the new message)*
timeout:: the delay (in milliseconds) after which messages should be released and aggregated, even though the completion criteria was not met. Due to the way this is implemented (see MessageGroupStoreReaper in the Spring Integration documentation), the actual observed delay may vary between `timeout` and `2xtimeout`. *(default: `60000`, _i.e._ one minute)*

