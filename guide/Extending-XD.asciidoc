=== Introduction
This document describes how to customize or extend the Spring XD Container. Spring XD is a distributed runtime platform delivered as executable components, including XD Admin, XD Container, and XD Shell. The XD Container is a Spring application utilizing a combination of XML resources, Java @Configuration classes, and Spring Boot auto configuration for its internal configuration, and initialized via the Spring Boot http://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/builder/SpringApplicationBuilder.html[SpringApplicationBuilder]. Since Spring XD is open source, the curious user can see exactly how it is configured. However, all Spring XD's configuration is bundled in jar files and not directly accessible to end users. Most users do not need to customize or extend the XD Container. For those that do, Spring XD provides hooks to:

* Provide additional bean definitions
* Override selected bean definitions with custom implementations

Customization scenarios might include:

* Add a <<Adding-a-New-Data-Transport,new data transport>>
* Add a Spring XD <<Plugin-Architecture,plugin>> to configure modules
* Embed a <<How-to-Add-a-Spring-Bean-to-the-XD-Container,shared component>> used by user provided Plugin, such as a GemFire cache or a data source
* <<Providing-a-New-Type-Converter,Providing additional>> link:Type-conversion[type converters]

This document provides an overview of XD Container internals and explains how to extend Spring XD for each of these scenarios. The reader is expected to have a strong working knowledge of the Spring Framework and Spring Integration. 

[[XD-Spring-Application-Contexts]]
==== Spring XD Application Contexts

The diagram below shows how Spring XD is organized into several Spring application contexts. Some understanding of the Application Context model is necessary for extending XD. In the diagram, solid arrows indicate a parent-child relationship. As with any Spring application a child application context may reference beans defined in its parent application context, but the parent context cannot access beans defined in the child context. It is important to keep in mind that a bean definition registered in a child context with the same id as a bean in the parent context will override or replace that bean definition in the child context. Essentially, creating a separate instance. Similarly,  a bean registered to any context will override an earlier bean definition with the same id. 

Most of Spring XD's extension hooks target the 'Plugin Context' shown below. Additionally, it is also possible to register an alternate MessageBus implementation in the 'Shared Server Context'. 

.The Spring XD Application Contexts
image::images/xd-application-contexts.png[scaledwidth="100%"]

While this arrangement of application contexts is more complex than the typical Spring application, XD is designed this way for the following reasons:

* *Bean isolation* - Some beans are "global" in that they are shared by all XD runtime components: Admin, Container, and Modules. Those allocated to the 'Shared Server Context' are shared only by Admin and Container. Some beans must be provided to <<Plugin-Architecture,Plugins>> used to configure 'Modules' but Plugins and Modules should not have visibility to certain critical runtime components. While complete isolation has proven difficult to achieve, the intention is to minimize any undesirable side effects. 

* *Bean scoping* - To ensure that single node and multi node configurations are logically equivalent, the Spring configuration is identical for the single node and distributed runtimes and avoids unnecessary replication of bean definitions.

* *Lifecycle management* - Plugins and Initializers used to configure application contexts are themselves configured as Spring beans and dynamically "discovered" during initialization. These beans must be fully instantiated prior to the creation of application context on which they operate. In order to ensure this, beans may be either registered in an isolated application context (i.e., not part of the hierarchy), such as the 'Bootstrap Context', or in a parent context which is always initialized before any of its descendants.  


[[Plugin-Architecture]]
==== Plugin Architecture

The XD Container at its core is simply a runtime environment for deploying Spring applications called 'Modules'. Each module runs in its own application context ('Module Context'). The Module Context is a child of 'Global Context' as modules share some bean definitions but otherwise is logically isolated from beans defined in the XD container.  The 'Module Context' is fundamental to the XD design. In fact, this is what allows each module to define its own 'input' and 'output' channels and to allow property values to be configured differently for each deployed instance of the same module definition. The http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/xd/module/core/Module.html[Module] interface, and its default implementation provide a thin wrapper around a Spring Application Context into which properties may be bound, profiles activated, beans added, modified, and ultimately "plugged in" to the XD Container.

The 'ModuleDeployer' itself is unaware of a module's configuration or how to wire the module into the XD runtime. Binding a module's channels to XD's data transport, for instance, is the responsibility of the http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/integration/x/bus/MessageBus.html[MessageBus] implementation for the configured transport. The MessageBus binding methods are actually invoked by the 'StreamPlugin' during the initialization of a stream module. To support jobs, XD provides a 'JobPlugin' to wire the Spring Batch components defined in the module during deployment, also invoking the MessageBus to support communications between XD and job modules. These, and other functions critical to XD are performed by classes which implement the http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/xd/module/core/Plugin.html[Plugin] interface. a Plugin oprates on every deployed Module which it is configured to support. Thus the ModuleDeployer simply invokes the deployment lifecycle methods implemented by every Plugin registered in the Plugin Context.

The ModuleDeployer calls `getBeansOfType(Plugin.class)` on its application context's parent, namely, the 'Plugin Context'. This means that adding your own plugin requires these steps:
  
 * Write a class to implement the http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/xd/module/core/Plugin.html[Plugin] interface
 * Add it and any dependent classes to Spring XD's class path
 * Follow conventions that allow Spring XD to discover your plugin configuration and register its beans in the Plugin Context

This is the topic of the next section      

[[How-to-Add-a-Spring-Bean-to-the-XD-Container]]
==== How to Add a Spring bean to the XD Container

This section applies to adding a 'Plugin', which might be a useful thing to do since a Plugin has access to every module as it is being deployed (see the previous section on Plugin Architecture). Moreover, it describes a generic mechanism for adding any bean definition to the Container's 'Plugin Context'.  Spring XD uses both Spring Framework's class path component scanning and wild card resource loaders to find components you add to specific locations in the class path. This means you may provide Java @Configuration and/or any classes annotated with the @Component stereotype in a configured base package in addition to bean definitions defined in an XML or Groovy resource in a configured resource location. These locations are given by the properties `xd.extensions.locations` and `xd.extensions.basepackages`, optionally configured in `servers.yml` down at the bottom:

----
# User Extensions: Where XD scans the class path to discover extended container configuration to adds beans to the Plugins context.
# Each property may be a comma delimited string. 'basepackages' refers to package names used for
# annotated component (@Configuration or @Component stereotypes) scanning. 'locations' is a list of root resource directories containing XML or Groovy configuration. 
# XD prepends classpath:* if no prefix included and appends **/*.* to each location
#xd:
#  extensions:
#      basepackages: com.acme.xd.extensions
#      locations: META-INF/spring-xd/ext
----    

As the pluralization of these property names suggests, you may define multiple values with a comma delimited string. Also note that there is no default for `xd.extensions.basepackages`. So if you want to use annotation based configuration, you must first set up one or more base package locations. The resource location(s) are the root location of any XML or Groovy Spring bean definition file in the root or any of its subdirectories and defaults to `META-INF/spring-xd/ext`

XD finds any bean definitions in its configured locations on the class path and adds them to the Plugin Context. This is the appropriate context in which to register these beans because in order to make use of custom beans in XD modules, you will likely want to provide a Plugin as well. 

NOTE: The extension mechanism is very flexible. In theory, one can define BeanPostProcessors, BeanFactoryPostProcessors, or ApplicationListeners to manipulate Spring XD Application Contexts but do so at your own risk as the Spring XD initialization life cycle is fairly complex, and not all beans are meant to be extensible.

Custom extensions should be packaged in a jar file and added to Spring XD's class path. Currently, you must manually copy the jar to `$XD_HOME/lib` for each container instance. To implement a Plugin, you will need to configure your build for a compile time dependency on `spring-xd-module`. To access other container classes and to test your code in a container you will also require `spring-xd-dirt`. 

[[Providing-a-New-Type-Converter]]
==== Providing A new Type Converter

Spring XD supports link:Type-conversion[automatic type conversion] to convert payloads declaratively. For example, to convert an object to JSON, you can add the module option `--outputType=application/json` to a module in a stream definition. The conversion is performed by a 'Plugin' that binds a Spring http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/MessageConverter.html[MessageConverter] to a media type. The default type converters are currently configured in https://github.com/spring-projects/spring-xd/blob/master/spring-xd-dirt/src/main/resources/META-INF/spring-xd/plugins/streams.xml[streams.xml], packaged in `spring-xd-dirt-<version>.jar`. If you look at that file, you can see an empty list defined. 

[source,xml]
----
<!-- Users can override this to add converters.-->
	<util:list id="customMessageConverters"/>
----

So registering a new type converter is a matter of registering an alternate list called `customMessageConverters` to the application context. Spring XD will replace the default empty list with yours. `xd.messageConverters` and `customMessageConverters` are two lists injected into the 'ModuleTypeConversionPlugin' to build an instance of http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/CompositeMessageConverter.html[CompositeMessageConverter] which delegates to the first converter in the list that is able to perform the necessary conversion. The Plugin injects the CompositeMessageConverter into the module's 'input' or 'output' the http://docs.spring.io/spring-integration/docs/4.0.0.RC1/api/org/springframework/integration/channel/AbstractMessageChannel.html[MessageChannel], corresponding to the `inputType` or `outputType` options declared for any module in the stream definition.

The CompositeMessageConverter is desirable because a module does not generally know what payload type it will get from its predecessor. For example, the converters that Spring XD provides out of the box can convert any Java object, including a http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/xd/tuple/Tuple.html[Tuple] and a byte array to a JSON String. However the methods for converting a byte array or a Tuple are each optimized for the specific type. The CompositeMessageConverter for --outputType=application/json must provide all three methods and chooses the first one that matches both the incoming payload type and the media type (application/json). Note that the order that the converters appear in the list is important. In general, converters for specific payload types precede more general converters for the same media type. The `customMessageConverters` are added last in the order defined. So it is easier to add converters for new media types than to replace existing converters. However both are possible. 

For example, a member of the Spring XD community inquired about Spring XD's support for https://developers.google.com/protocol-buffers/[Google protocol buffers]. This user was interested in integrating Spring XD with an existing messaging system that uses GPB heavily and needed a way to convert incoming and outgoing GPB payloads for use with XD streams. This could be accomplished by providing a `customMessageConverters` bean containing a list of required message converters. Writing a custom converter to work with XD requires extending http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/integration/x/bus/converter/AbstractFromMessageConverter.html[AbstractFromMessageConverter] provided by `spring-xd-dirt`. It is recommended to review the existing implementations listed in https://github.com/spring-projects/spring-xd/blob/master/spring-xd-dirt/src/main/resources/META-INF/spring-xd/plugins/streams.xml[streams.xml] to get a feel for how to do this. In addition, you would define a new http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/MimeType.html[MimeType] such as `application/gpb`. 

NOTE: It is worth mentioning that GPB is commonly used for marshaling objects over the network. However, in the context of Spring XD, marshaling is a separate concern from payload conversion. In Spring XD, marshaling happens at the "pipe" indicated by the '|' symbol and uses a different serialization protocol. In this case, the GPB payloads are produced and consumed by systems external to Spring XD and need to be converted in order to benefit from Spring XD's stream processing capabilities.

As an illustration, suppose this user has developed a source module that emits GPB payloads from a legacy service. Spring XD provides transform and filter modules that accept SpEL expressions to perform their respective tasks. These modules are useful in many situations but the SpEL expressions generally require a POJO representing a domain type, or a JSON string. In this case it would be convenient to support stream definitions such as

----
gpb-source --outputType=application/x-java-object | transform --expression=... 
---- 

where 'gpb-source' represents a custom module that emits a GPB payload and 'expression' references some specific object property. The media type application/x-java-object is a convention used by XD to indicate that the payload should be converted to a Java type embedded in the serialized representation (GPB in this example). Alternately, converting to JSON could be performed if the stream definition were:

----
gpb-source --outputType=application/json | transform --expression=... 
---- 

To convert an XD stream result to GPB to be consumed by an external service might look like:

----
source | P1 ... | Pn | gpb-sink --inputType=application/gpb
----

These examples would require registering custom MessageConverters to handle the indicated conversions.
Alternately, this may be accomplished by writing custom processor modules to perform the required conversion. The above examples would then have stream definitions that look more like: 

----
gpb-source | gpb-to-pojo | transform --expression=... 
source | P1 ... | Pn | json-to-gpb | gpb-sink 
---- 

TIP: While custom processor modules are easier to implement, it adds unnecessary complexity to the stream definitions that use them. If common conversions are required everywhere, enabling automatic conversion simplifies things. Also, note that using a separate module generally requires that payload to be serialized and transported over the network. If this is necessary just to perform a common conversion task, it is less efficient than using declarative conversion.      


[[Adding-a-New-Data-Transport]]
==== Adding a New Data Transport

Spring XD provides redis and rabbit for data transport out of the box. It is configured simply by setting the property `xd.transport` to one of these values. In addition xd-singlenode supports a `--transport` command line option that can accept 'local'(the single node default) as well as `redis` and `rabbit`. This simple configuration is supported internally by an import that binds the transport implementation to a name. 

[source,xml]
-----
<import resource="classpath*:/META-INF/spring-xd/transports/${XD_TRANSPORT}-bus.xml"/>
-----

The above snippet is from an internal configuration file loaded by the 'Shared Server Context'. Spring XD provides MessageBus implementations in `META-INF/spring-xd/transports/redis-bus.xml` and `META-INF/spring-xd/transports/rabbit-bus.xml` 

This makes it relatively simple for Spring XD developers, including you, to provide alternate MessageBus implementations to enable a new transport and activate that transport by setting the `xd.transport` property. For example, to implement a JMS MessageBus you would add a jar containing `/META-INF/spring-xd/transports/jms-bus.xml` in the class path. This file would register a bean of type 'MessageBus' with the ID `messageBus`. The jar also must provide the MessageBus implementation and any dependencies be installed `$XD_HOME/lib`. 

When implementing a MessageBus, it is advisable to review and understand the existing implementations which extend http://docs.spring.io/spring-xd/docs/1.0.0.M6/api/org/springframework/integration/x/bus/MessageBusSupport.html[MessageBusSupport] which performs some common tasks including payload marshaling. Spring XD uses the term 'codec' to imply serialization and deserialization and provides a bean with the same name. In the example above, the JMS MessageBus configuration`/META-INF/spring-xd/transports/jms-bus.xml` might look something like:

[source,xml]
-----
<bean id="messageBus" class="my.example.JmsMessageBus">
	<constructor-arg ref="jmsConnectionFactory" />
	<constructor-arg ref="codec"/>
</bean>
-----

where JmsMessageBus extends MessageBusSupport and the developer is responsible for configuring any JMS resources appropriately.




